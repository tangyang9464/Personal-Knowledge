#### MyISAM和InnoDB区别

- 行级锁（针对索引加锁）
- 事务以及事务安全性操作，如崩溃后的安全恢复
- 外键
- MVCC-多版本并发控制：用于高并发，写的时候会添加一个新的版本而不是修改，所以不会影响读

**实现**：每列有隐藏字段，存储创建时间和过期时间；事务开启时候会有一个版本号进行比对

##### 	定义

​	一系列逻辑操作，要么全部执行，要么都不执行，不允许完成部分

##### 	四个特性（ACID）

- 原子性（Atomicity）：操作只能全部完成，不能部分
- 一致性（Consistency）：数据从一个正常状态变为另一个正常状态
- 隔离性（Isolation）：事务执行不能被其他事务干扰，互相隔离
- 持久性（Durability）：事务正确完成后，数据的改变是永久性的

##### 并发事务的4个问题

- 脏读：一个事务读取了另一个事务还没有提交的数据
- 丢失修改：两个事务同时访问数据，一个修改了数据，另一个也修改，那么第一个的修改就丢失了
- 不可重复读：一个事务重复读取，但数据不一致，因为途中另一个事务修改了数据
- 幻读：一个事务读取了几行数据，另一个事务插入了几行，刚才的事务再读的时候会发现多了一些原本不存在的数据

##### 隔离级别

- read uncommitted：读取未提交
- （RC）read committed：读取已提交--解决脏读
- （RR）repeatable read：可重复读--解决不可重复读 
- serializable：可串行化--解决幻读

注：Mysql默认支持repeatable read级别，但独特地只用了Next-key lock锁，因此可以避免幻读的产生，使得其达到了ACID的要求

**Next-key lock**：行锁和间隙锁的组合，查询时带有非唯一索引时，会锁住索引本身记录和它的间隙；若为唯一索引，会变为行锁（因为唯一索引就决定了查询时只有一条记录）

#### 索引

##### 分类

- 普通索引、主键索引、唯一索引、全文索引、组合索引

##### 最左匹配原则

联合索引以最左边的索引为准，只要查询条件有最左边的索引，那么就会使用

##### 覆盖索引

有联合索引(a,b,c)，查询select a,b,c from table where a=..，select的列和索引刚好一样，就是覆盖所引。

这样避免了回表查询，因为在叶节点就能查到索引值

##### 回表

查询非聚簇索引需要再到聚簇索引中去查询数据记录，叫做回表

##### 定义

一种数据结构，用来快速检索数据库中的数据

##### 采用的数据结构 

- Hash索引： 
  - 键值对形式，多条数据完全没有顺序，适合等值查询、不能区间查询和排序；
  - 重复键值的情况下效率低，因为会出现哈希碰撞
- B+树索引：多路平衡树，数据天然有序（二叉搜索树）
  - InnoDB将主键组织到一颗B+树，叶子节点存放数据
  - MyISM叶子节点存放的是数据的地址

##### 为什么采用B+树（多叉树、叶节点、横向链表、天然有序）

- 为外部设备设计、多叉树，更多子节点，每个子节点存储更多值；高度低，磁盘IO次数少；查询速度快

- 非叶子节点只存储指针，叶子节点存储数据。能存储的数据更多，查询时间复杂度稳定在logN
- 叶节点用链表连接，更好地利用局部性原理；天然有序，更适合区间查询和排序
- Hash没有顺序，不能区间查询和排序，重复键多的情况发生碰撞，效率降低

##### 聚簇索引

- 该索引中键值的逻辑顺序决定了表中相应行的物理顺序，找到索引的同时找到数据
- InnoDB将主键组织到一颗B+树，叶子节点存放数据
- 辅助索引：存放非主键，叶子节点存放主键，二次查找后找到数据

##### 非聚簇索引

- 该索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同，索引和数据分开放，索引结构的叶结点存放数据的地址
- MyISM使用，两颗B+索引树，存放主键和辅助键，叶节点都存放数据的地址

##### 索引不生效的情况

- 运算：字符串替换、加减运算、 函数转换
- 以%开头的like
- 联合索引不包含最左边的索引

#### SQL优化

- 优化sql语句：加上限定范围、不要全表扫描
- 使用索引、并避免索引不被使用
- 读写分离

#### Redis

##### 数据结构

- **list**：双向链表
- **set**：hashTable
- **zset**：比set多了一个score参数，可用于排序
- **hash**：hashTable
- **string**：字符串键值对、动态字符串

##### 缓存穿透

大量请求的 key （一定不存在）根本不存在于缓存中，导致请求直接到了数据库上，根本没有经过缓存这一层

- 解决：**布隆过滤器**或者缓存空值，设置过期时间很短

**布隆过滤器**：位数组，用K个hash函数计算key得到多个位置，将位数组中对应位置置为1

若查询不存在就一定不存在，若存在可能几率误判

##### 缓存击穿

**某个key**失效，大量请求同时到来

- 解决：利用redis设置互斥锁，获取不到锁的线程就等待缓存值被写入，重新尝试查询缓存值

##### 缓存雪崩

同一时刻**多个key**大面积失效或者**redis宕机**，导致请求全部到了数据库

- 解决：集群缓存+基础时间上加上一个随机时间+限流降级等

##### 3种缓存策略

- **Cache-Aside**：读缓存，没有就读db，写入缓存；写db，删除缓存
- **Write/Read-Through**：与上面类似，区别是程序**只跟缓存打交道**，读写db交给缓存去做。write适用于频繁读取，不能忍受数据不一致
- **Write-Behind**：与上述区别是不会立即写入数据库，而是**异步方式**