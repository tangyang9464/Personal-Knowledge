# IM即时通讯系统

## 项目流程

1.   TCP连接。客户端通过zookeeper获取可用服务器，使用负载均衡算法选择服务器进行连接。连接成功后将userid和serverInfo保存在redis
2.   客户端发送握手包，包括userid。
3.   服务端进行登录验证，主要验证是否重复登录。验证成功发送响应包，并保存相应的userid和channel上下文
4.   客户端收到响应包后启动心跳计时器。使用NioEventLoop的定时器
5.   开始通信

## 项目功能

### 私聊

通过命令显示当前在线用户，客户端给对应用户发消息，服务端接收到消息后，判断touser是否在当前服务器，若在直接转发。若不在，就发到kafka相应用户的topic。另一服务器订阅topic消费，找到相应的用户转发消息。

### 群聊

服务器接收消息后发到group的topic，所有服务器都订阅该topic，然后消费消息转发给自己服务器的所有用户。

## 网路连接可靠性

### 心跳检测

客户端握手成功就会启动定时器发送心跳包。通过userTrigger来判断心跳超时。若N次没有得到响应，那么就尝试重新连接或者断开连接

### 断线重连

- 启动失败重连
	通过回调函数进行重连
- 运行服务器掉线
	通过handler的Inactive方法监听掉线，如果掉线就重新选择服务器进行连接

### 消息即时性

维持长连接

### 消息可靠性

TCP连接，Kafka发送重试以及持久化机制

### 消息安全性

http的话可以直接使用https
通过非对称加密

## ProtoBuf

-    序列化框架的评价标准
     1. 编码后的码流长度
     2.编解码的性能
     3.是否支持跨语言，支持的语言种类
     4.API使用简便性
-    优势
  -    性能好
  -    文本化的数据结构描述语言，易兼容和维护，可以实现语言，平台无关。

## 多种方案

1. HTTP接口调用

	设置一个路由层，发送消息通过http接口，通过路由层实现群发或者私聊，路由层也是通过调用服务器http接口。然后服务器回复消息使用netty

2. 服务器之间长连接

	服务器与其他服务器进行通信转发，相当于自己进行中转。维护的连接比较多，每个服务器既是netty客户端又是服务端，比较麻烦

3. 消息队列中转

	逻辑清晰，模块耦合度低，易于维护

## WebSocket

实现全双工通信，改变了HTTP服务器不能主动push消息的弊端。

-    轮询：客户端不停发送请求，服务端立即响应，达到一种push消息的功能
-    长轮询：服务器只当有新数据的时候才响应，否则就挂起请求。

## 为什么不使用Tomcat

tomcat是基于http协议的。而netty既是基于NIO的多路复用机制，又能自定义通信格式

## 自定义通信格式

|  字段  | 长度 |                描述                 |
| :----: | :--: | :---------------------------------: |
|  魔数  |  1   |                0xAB                 |
|  长度  |  4   |           除魔数外的长度            |
| 包类型 |  1   | 包类型，包括握手、心跳、群聊-私聊包 |
| 发送者 |  4   |              发送者id               |
| 接收者 |  4   |              接收者id               |
| 数据包 | 不定 |           发送的消息主体            |

魔数4+包类型1+发送者4+接收者4+数据包
包类型包括握手包，心跳包，群聊包，私聊包
握手包用于确认客户端是否重复登录

## Netty面试题

### ByteBuf

本质是一个数组，可动态扩展，维护了读写两个指针，用于支持顺序读写的操作。

-    **堆内存**

-    **直接内存**

     即堆外内存，直接向系统申请的内存。
     它读写socketChannel会少一次拷贝
     正常流程：内核socket_用户堆外内存_堆内存

# RPC系统

## 使用流程

客户端使用动态代理生成代理类，通过代理类调用方法。

调用方法会从zookeeper中获取服务地址，通过负载均衡算法挑选出可用服务地址。使用netty进行TCP连接。发送接口名，方法名，方法类型，方法参数。

服务端收到消息后，通过map查找出相应的实现类，通过反射调用方法得到结果再返回。

## 消息格式

数据包长度--接口名--方法名--方法类型--方法参数

# 实习

## 全局异常处理

通过SpringBoot的`ControllerAdvice`注解创建全局异常处理类，通过`ExceptionHandler`注解指定不同异常的处理类

统一返回结果对象`ResponseResult`，包括code、msg、data。

大体种类有：

1000--登录错误

1001--VIP权限错误

2000--数据库token错误

非微信平台打开错误

## 拦截器实现登录验证

实现`HandlerInterceptor`接口，并在实现`WebMvcConfigurer`接口并注册拦截器

以前的方式是在指定的controller里面进行重复编码验证

## 策略模式替换if/else

需求是后台微信菜单需要根据不同指令做不同的事情。比如点击事件，用户点击按钮后台返回联系方式。订阅事件，用户订阅后后台发送欢迎语。

因为有很多种事件，用了多重if/else，不是很好维护。

定义一个接口，有一个process方法。不同事件实现同一个接口。有一个context类根据事件名称通过反射获取到对应的实现类。其中事件名称和对应实现类的限定名用一个枚举类来维护。

