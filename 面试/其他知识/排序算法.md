#### 排序算法

##### 快速排序

```java
public static void quicksort(int[] arr,int L,int R){
        if(L>R){
            return;
        }
        int tar = arr[L];
        int i=L,j=R;
        while (i<j){
            while (i<j && arr[j] >= tar){
                j--;
            }
            if(i==j) {
                break;
            }
            arr[i]=arr[j];
            while (i<j && arr[i] < tar){
                i++;
            }
            if(i==j) {
                break;
            }
            arr[j]=arr[i];
        }
        arr[i]=tar;
        quicksort(arr,L,i-1);
        quicksort(arr,i+1,R);
    }
```

###### 时间复杂度

![](https://pic1.zhimg.com/80/v2-d5b13e6e4a65005caa8afe085e81172f_1440w.jpg?source=1940ef5c)

###### 空间复杂度

每次递归为常数，递归深度为logN，所以复杂度为logN

##### 归并排序

```java
public static void sort(int[] arr,int L,int R){
        if(L>=R) {
            return;
        }
        int mid = (L+R)/2;
        sort(arr,L,mid);
        sort(arr,mid+1,R);
        merge(arr,L,mid,mid+1,R);
    }
    public static void merge(int[] arr,int La,int Ra,int Lb, int Rb){
        int[] newarr = new int[Rb-La+1];
        int pos=0;
        int i=La,j=Lb;
        while (i<=Ra || j<=Rb){
            int a,b;
            a = i>Ra ? Integer.MAX_VALUE : arr[i];
            b = j>Rb ? Integer.MAX_VALUE : arr[j];
            if(a<b){
                newarr[pos++]=a;
                i++;
            }
            else{
                newarr[pos++]=b;
                j++;
            }
        }
        for(int k=La;k<=Rb;k++){
            arr[k]=newarr[k-La];
        }
    }
```

##### 堆排序

```Java
public static void heapsort(int[] arr){
        //先构建堆（每个节点调整一次）
        for(int i=(arr.length-1-1)/2;i>=0;i--){
            adjust(arr,i,arr.length);
        }
        //将堆顶放到末尾，然后减少长度并调整
        for(int i=arr.length-1;i>=0;i--){
            int tmp = arr[0];
            arr[0] = arr[i];
            arr[i] = tmp;
            adjust(arr,0,i);
        }
    }
    public static void adjust(int[] arr,int root,int len){
        if(root>=len) {
            return;
        }
        while (root*2+1 < len){
            int tar = root*2+1,R=root*2+2;
            if(R < len && arr[tar] < arr[R]){
                tar = R;
            }
            if(arr[tar] > arr[root]){
                int tmp = arr[root];
                arr[root]=arr[tar];
                arr[tar]=tmp;
            }
            else{
                break;
            }
            root = tar;
        }
    }
```

###### 时间复杂度

树的高度H，节点数N，则N=2^H-1

建堆复杂度：

从下往上，调整的节点数为该层的高度*节点数，即1\*2^(h-1),相加求和（错位相减）得到2^(h-1)-h,代入N得到O（N）；也可以用递归的思想，左右堆调整为T（N/2）,顶点调整为logN，用快排递推的方法即可得到

排序复杂度：每次调整为logN，调整N-1次，即NlogN

##### 冒泡排序

```Java
public static void bubblesort(int[] arr){
        for(int i=arr.length;i>0;i--){
            for(int j=1;j<i;j++){
                if(arr[j] < arr[j-1]){
                    int tmp = arr[j];
                    arr[j] = arr[j-1];
                    arr[j-1] = tmp;
                }
            }
        }
    }
```