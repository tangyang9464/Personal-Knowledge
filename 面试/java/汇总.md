### 基础

#### static关键字

##### 修饰方法、变量

表示属于类，多个对象共享。调用时直接用类名就行，不需要创建实例

##### 修饰内部类

这个内部类独立与外围类，可以单独创建使用；不能使用任何外围类的非static变量

##### 修饰代码块

类的static代码块最先执行，只执行一次

##### import static

用于引入类的静态方法和成员，不用加类名就能直接使用

### 集合

#### 概览

- 

<img src="https://snailclimb.gitee.io/javaguide/docs/java/collection/images/Java-Collections.jpeg" style="zoom:50%;" />

#### ArrayList扩容机制(构造方法）

- 无参构造（不指定初始容量）：起初创建一个空数组，add第一个元素时会将容量由0增加到10，后扩容是1.5倍左右
- 有参构造（指定了容量）：超出容量后就扩容1.5倍左右 

#### HashMap

##### 原理概述（hash过程）

- **原理**：数据结构采用数组+链表+红黑树的方式，通过key的hashCode经过扰动函数处理后得到hash值，再通过（n-1）&hash找到元素的位置，若存在，则判断是否相同，相同覆盖，不同就采用链表处理冲突
- **扰动函数（hash函数）**：HashMap的hash函数，将hash值>>>16位后与原值异或，也就是高位和低位异或。避免hashCode函数性能较差，减少冲突
- **链表变红黑树的条件**：当链表元素大于8，若HashMap容量<64就扩容，>64就变成红黑树

##### 扩容机制（阈值，rehash，头插法）

- **概述**：达到阈值后，扩容为原来的2倍，重新计算元素的位置，将元素移动到新容器中
- **rehash**:jdk1.8以后e.hash & oldCap==0，原索引或者原索引+oldCap（旧容量）
- **插入新容器**：1.7头插法并发会产生死循环。1.8改为顺序插入

- **初始容量为16，加载因子为0.75**
- **扩容条件**：当达到容量\*加载因子（16\*75）时，扩容为原来的两倍

##### 线程不安全原因

- **JDK1.7扩容采用头插法形成循环链表**
- **put操作可能丢失修改**（同时操作头节点，判断为null后修改覆盖）

##### ConcurrentHashMap

- **存储结构**
	- **JDK1.7**：Segment数组+HashEntry数组，每个Segment类似于一个HashMap。在Segment上加锁。初始化数量后不可改变，最多16个。
	- **JDK1.8**：Node数组+链表+红黑树。对Node（链表红黑树的头节点）进行CAS和Synchronized同步加锁，锁粒度减小

##### HashMap，HashTable，ConcurrentHashMap区别

- **记忆**：初始容量（11，16）、扩容机制（2倍，2倍+1）、null值、线程安全的底层数据结构

- HashMap线程不安全，另外两个线程安全；Hahsmap初始容量为16，扩容为2倍，HashTable为11，扩容为2倍+1；HashMap的key和value均可以为null，其他不行；

- HashTable用Synchronized锁住整张Hash表，效率低；ConcurrentHashMap采用数据分段加锁 (细说底层如Segement数组)


### JVM

#### JVM内存区域

##### JVM内存区域（内存模型、运行时数据区域）

<img src="https://snailclimb.gitee.io/javaguide/docs/java/jvm/pictures/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F.png" style="zoom:50%;" />

- **程序计数器：** 通过改变这个计数器的值来选取下一条需要执行的字节码指令

	**它是唯一一个不会出现 `OutOfMemoryError` 的内存区域**

- **Java虚拟机栈：**存放Java方法的参数，变量和局部变量等信息

- **本地方法栈**：用于native方法使用

- **堆**：存放对象实例和数组，GC的主要区域

- **方法区**：被虚拟机加载的类信息、常量、静态变量等（1.8后变成了元空间，放在直接内存中）

##### 创建对象的五步

- **类加载检查：**检查常量池中是否有这个类的符号引用，并检查是否加载初始化过；若没有，执行类加载
- **分配内存**
	- **方法**
		- **指针碰撞法（内存规整）**：将内存分为已使用和未使用，用一个指针相隔，分配时就将指针移动指定大小
		- **空闲列表（内存不规整）：**维护一个可用列表，从列表中找出一块可用的内存
	- **并发问题**
		- CAS机制保证分配动作的原子性
		- 每个线程预先在堆分配一块内存，给对象分配时就在每个线程自己的这块内存上分配，用完了再分配新的
- **初始化0值**：将分配的内存置0，以便能够直接使用
- **设置对象头**：包含GC分代年龄、hashCode、锁状态标志等信息
- **执行init**：按照程序员的意愿初始化字段

##### 对象内存布局

- **对象头**
	- **自身运行时数据（Mark Word）**：GC分代年龄、hashCode、锁状态标志等
	- **类型指针**：指向类元数据，表示它是哪个类的实例
- 实例数据
- 对齐填充：要求对象大小为8字节整数倍，对象头为8字节或16字节(取决于机器位数)

##### 对象的访问方式

- **句柄**：在堆中分出一块内存为句柄，引用存的就是句柄的地址，句柄再指向实例
- **直接指针**：引用直接保存的就是实例地址

#### GC垃圾回收

##### 对象死亡判断的2种方法

- **引用计数法**

- **可达性分析**（图）：从GC ROOT向下搜索，若该对象不可达，则不可用；后判断是否有必要执行finalize方法（覆盖finalize方法或者已经执行过了）；若必要就二次标记，没有建立其他引用就回收；

	**GC ROOT**

	- **栈**：虚拟机栈、本地方法栈中引用的对象
	- **方法区**：类静态属性、常量引用的对象

##### Full GC（大对象进入）

- 回收堆、方法区
- 条件
	- **老年代空间不够**：新生代大对象、大数组转移
	- **方法区空间不够**

##### 四种引用（强、软、弱、虚）

- **强引用**：不会回收
- **软引用**：内存不够回收
- **弱引用**：发现就回收（不管内存够不够）
- **虚引用**：跟没有引用一样，必须配合引用队列使用，用于跟踪对象回收的活动

##### 无用的常量和类

- **常量**：没有String引用的常量会从常量池中回收
- **类**
	- 无实例
	- 无加载该类的ClassLoader
	- 无Class对象的使用

##### GC算法

- **标记-清除**：标记得是**不需要回收的对象**，然后清除没有标记的对象
	- 效率低、碎片化高
- **复制算法**：将内存分为两部分，每次使用其中一块，用完后就将存活对象复制到另外一块，然后清除。
	- 效率高
- **标记-整理**：标记后，将标记对象移动到另一端，清除边界以外的对象
- **分代收集**：将内存分代，然后采用不同的上述几种算法；**新生代-复制法**，**标记法**

##### GC优化

尽量在新生代回收，避免过大过多的对象进入老年代

- 合理设置年龄大小，以及老年代的空间大小，避免Full GC

##### GC收集器

- 初代
	- Serial：单线程，需要停止用户线程
	- ParNew：多线程版本
- 现行
	- **CMS**：注重用户体验，**以获取最短回收停顿时间为目标**。采用**标记-清除算法**
		- **步骤**
			- **初始标记**：停下其他线程，标记**直接与Root相连的对象**
			- **并发标记**：从Root记录可达对象，但由于用户线程在更新，没有实时性；
			- **重新标记**：修正上一步更新的记录（会停止用户线程）
			- **并发清除**
	- **G1**：面向服务器，**以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.**
		- **特点**
			- G1将堆分为多个Region，在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region
			- **并行与并发**：充分利用多CPU减少停顿
			- **分代收集**：G1保留了分代的概念
			- **空间整合**：整体是”标记-整理“，局部是”复制“
			- **可预测的停顿**：使用者可以明确指定GC时间

#### 类加载过程

##### **加载**

- 通过全类名获取二进制字节流并转换为方法区的数据机构
- 在内存中生成Class对象作为数据访问入口

##### **验证**

<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E9%AA%8C%E8%AF%81%E9%98%B6%E6%AE%B5.png" style="zoom:50%;" />

##### **准备**

- 正式为类变量分配内存并设置类变量初始值的阶段，初始值除了final其余均为0（null）

##### **解析**

- 将符号引用变为直接引用；

##### **初始化**

- 执行字节码（主动使用类才会初始化）

#### 类生命周期

​	<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B-%E5%AE%8C%E5%96%84.png" style="zoom:50%;" />

#### 类加载器

##### **BootstrapClassLoader(启动类加载器)** 

- 最顶层的加载类，由C++实现，负责加载 `%JAVA_HOME%/lib`目录下的jar包和类或者或被 `-Xbootclasspath`参数指定的路径中的所有类。

##### **ExtensionClassLoader(扩展类加载器)** 

- 主要负责加载目录 `%JRE_HOME%/lib/ext` 目录下的jar包和类，或被 `java.ext.dirs` 系统变量所指定的路径下的jar包。

##### **AppClassLoader(应用程序类加载器)** 

- 面向我们用户的加载器，负责加载当前应用classpath下的所有jar包和类。

#### 双亲委派模型



<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/classloader_WPS%E5%9B%BE%E7%89%87.png" style="zoom:50%;" />

- 加载时将请求委派给父加载器，检查是否加载过。如果不能处理才由自己加载；总之**就是自底向上的检查是否加载过，自顶向下的尝试加载类**
- 优点
	- 避免类重复加载
	- 防止Java的API被篡改，比如用户自定义Object类，运行时出现多个Object类

### 多线程

#### Java线程状态

- New
- RUNNABLE--包括就绪和运行
- BLOCKED--等待锁
- WAITING--wait方法、需要其他线程唤醒
- TIMED_WAITING--超时等待
- TERMINATED--结束

#### 进程与线程的区别

- 线程是进程的一个子任务

- 进程是资源分配的基本单位、线程是调度的基本单位（**调度**）

- 进程单独占有内存空间地址及其他系统资源（如IO）（**资源**），通信复杂

	线程共享所属进程的内存地址空间和资源，通信简单

- 进程切换不仅需要保存寄存器和栈信息，还需要资源的分配回收、开销较大、线程只需要保存栈和寄存器开销小（**开销**）

#### 创建线程的方法

- 继承Thread方法、重写run方法
- 实现Runnable接口的run方法
- Executor（线程池）
- FutureTask（有返回值）

#### Java线程4种通信方式

- 共享变量：使用volatile修饰的变量
- 等待/通知机制：wait、notify
- 管道：pipeReder
- 消息队列

#### volatitle作用

- 保持**线程可见性**：一个线程修改了共享变量的值，其他线程能立即得知这个修改。（线程有私有本地内存，修改变量后刷新回主内存，但其他线程的私有内存并没有更新，还是使用的旧值。）
- 防止**指令重排序**:计算机在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排

#### 并发三点特性（volatitle和synchronized）

- **原子性**：一个或多个操作执行过程中不被打断的特性
- **可见性**：一个线程改变了共享变量之后，其他线程能够立即知道这个变量被修改
- **有序性**：程序按照代码先后顺序执行

#### synchronized锁升级（Java6以后）

- **无锁**
- **偏向锁**：（不需要锁和CAS）
	- **概念**：偏向锁会偏向于第一个访问锁的线程，如果在接下来的运行过程中，该锁没有被其他的线程访问，则持有偏向锁的线程将永远不需要触发同步
	- **升级**：若有新的线程，则尝试CAS更新，失败就升级锁
	- **获取锁**：第一次进入同步块时，会在对象头和栈帧中的锁记录里存储锁的偏向的线程ID，下一次检查锁的Mark Word里面是不是放的自己的线程ID
- **轻量级锁（自旋锁）**：
	- **概念**：通过自旋获取锁
	- **获取锁**：将MarkWord复制到自己的栈，然后尝试CAS更新MarkWord为指向此锁记录的指针，失败就使用自旋
	- **升级**：自旋次数过多，就升级。
- **重量级锁**
	- **概念**：依赖于操作系统的互斥量（mutex） 实现的，需要线程状态转换。

#### synchronized底层实现

JVM基于进入和退出monitor对象来实现方法和代码块同步

- **方法**：隐式，无需字节码指令；

	调用方法时检查标志是否为同步方法，尝试持有monitor对象

	返回时释放对象

- **代码块**：通过monitorenter和monitorexit两个字节码指令

	分别位于开始和结束的位置

	monitorenter指令执行尝试获取锁，计数器+1

	monitorexit指令执行计数器-1，变为0就释放

#### 乐观锁与悲观锁

- **乐观锁**：数据操作不加锁，只在最终更新数据的时候才检验当前数据是否被修改过，也就是CAS操作
- **悲观锁**：数据操作之前需要加锁，完成后释放锁

#### 原子操作

- 要么执行完所有步骤，要么一步也不执行，不可能只执行所有步骤的一个子集的一组操作
- **CAS**：
	- 比较并交换，是一种不需要加锁就能完成原子操作的技术；判断要修改的变量是否等于预期值，等于就更新值；不等于则说明变量被其他线程修改过了，此次操作失败，重新进行操作，不会挂起
	- ABA问题：一个值原来是A，变成了B，又变回了A。这个时候使用CAS是检查不出变化的，解决方法是变量加版本号或时间戳
	- 缺点：ABA、循环消耗CPU（循环一定时间后睡眠），只能共享一个变量
- **Atomic类**

#### AQS（Lock的底层实现）

- 抽象队列同步器，提供了一种实现阻塞锁和一系列依赖FIFO等待队列的同步器的框架

- **数据结构**：volatile变量state，双向链表（等待队列）
- **资源共享模式**：独占式、共享式
- **state的访问方式**
	- getState
	- setState
	- compareAndSetState
- **获取资源**：获取到就返回，没有就通过CAS将线程Node插入等待队列，通过state判断资源是否加锁，通过等待队列来存放阻塞的队列

#### 线程池

##### 创建方式

- **ThreadPoolExecutor**：提供7大参数自定义
- **Executor**：创建特定的线程池，如4种常用的线程池

##### 组成

- **线程管理池**：负责线程池的创建销毁等
- **工作线程**：循环执行任务，没有任务就等待
- **任务接口**：每个任务需要实现任务接口供工作线程调度，规定了任务的入口，收尾状态等
- **任务队列**：存放等待执行的任务

#####  **使用原因**

  - 创建/销毁线程需要消耗系统资源，线程池可以**复用已创建的线程**。
  - **可以对线程做统一管理，控制并发的数量**。并发数量过多，可能会导致资源消耗过多，从而造成服务器崩溃。（主要原因）

##### **状态**

  - RUNNING
  - SHURDOWN
  - STOP
  - TIDYING：所有任务终止并且任务数为0
  - TERMINATED

##### **ThreadPoolExecutor的5大参数**

  - corePoolSize：核心线程的最大值（核心线程默认会一直存在，非核心闲置过久会销毁）
  - maximumPoolSize：最大线程数
  - keepAliveTime：非核心线程闲置时间
  - TimeUnit：keepAliveTime的单位（毫秒、秒等）
  - BlockingQueue ：存储着等待执行的Runable任务对象
	- LinkedBlockingQueue
	- ArrayBlockingQueue
	- SynchronousQueue（put和take操作）
	- DelayQueue

##### **ThreadPoolExecutor的2个非必要参数**

  -  threadFactory：设置一些参数，如守护线程等
  -  RejectedExecutionHandler：拒绝处理策略

##### **拒绝处理策略（超出最大线程数后）**

  - 默认-丢弃任务并抛出异常
  - 只是丢弃任务
  - 丢弃队列头部并重新尝试执行，若失败再次重复
  - 交给调度线程处理

##### **执行流程**

  - 线程数 < corePoolSize,新建核心线程执行，以便快速达到corePoolSize
  - 线程数>=corePoolSize，进入等待队列，空闲的核心线程会依次去缓存队列中取任务来执行
  - 队列满了后新建非核心线程
  - 达到maximumPoolSize后执行拒绝策略

##### **复用**

- 完成任务后会循环的从队列中取出任务来执行而不是销毁，如果没有任务执行就阻塞

##### **4种提供的常用线程池**

  - CachedThreadPool：只有非核心线程，线程池数量多（Integer.MAX_VALUE，2的31次方-1），适合短时间任务
  - FixedThreadPool：只有核心线程，缓冲队列长；没有任务的情况下， FixedThreadPool占用资源更多
  - SingleThreadExecutor：单一核心线程，通过先来先服务执行任务
  - ScheduledThreadPool：定长线程池，支持定时及周期性任务执行

#### 阻塞队列

- **定义**：提供了线程安全的队列访问方式
- **类型**
	- **有界**
		- ArrayBlockingQueue：初始化容量后不能改变，基于数组
		- LinkedBlockingQueue：容量为Integer.MAX_VALUE。线程池的使用队列
	- **无界**
		- DelayQueue：在一定延迟后才能取数据
		- PriorityBlockingQueue：内部采用公平锁
		- SynchronousQueue：put后必须take，否则阻塞等待，反之亦然；
- **原理**：使用Lock锁的多条件阻塞
	- Lock锁的多条件阻塞：同一把锁，提供多个阻塞队列，而不是像wait/notify是一把锁只有一个队列
	- 获取锁、判断队列满或空、阻塞或执行、唤醒另一条件线程（生产者和消费者）

#### 锁的接口和类（Lock）

- **与synchronized区别（层面、锁释放、中断、判断）**
	- synchronized是关键字，字节指令实现；Lock是接口，实现类底层用CAS实现
	- synchronized异常会释放锁，Lock需要在finally中释放
	- synchronized不可中断，不能判断锁状态
	- synchronized功能单一，Lock提供更多个性化		

- **接口Lock的实现类**
	- ReentrantLock：默认实现，包括公平（FIFO）和非公平
- **ReadWriteLock接口**
	- ReentrantReadWriteLock：读写锁，可以返回读锁和写锁
- **StampedLock**：比读写锁性能更好，在读的时候如果发生了写，应该通过重试的方式来获取新的值，而不应该阻塞写操作。（CAS自旋） 

