

# Java基础

## 集合

### 概览

- 

<img src="https://user-gold-cdn.xitu.io/2019/5/5/16a87863d7e712b7?imageslim" style="zoom:%;" />

### ArrayList扩容机制(构造方法）

- 无参构造（不指定初始容量）：起初创建一个空数组，add第一个元素时会将容量由0增加到10，后扩容是1.5倍左右

     （`oldCapacity + (oldCapacity >> 1)`）,奇偶不一样，所以是左右

- 有参构造（指定了容量）：超出容量后就扩容1.5倍左右 

### 红黑树

- 每个节点要么红、要么黑
- 根节点、叶子节点都为黑色
- 每个红节点的子节点为黑色
- 任意节点到叶子节点的路径包含的黑色节点数目一样

概述：黑根黑叶红不邻，路径等黑。

### HashMap

#### 原理概述（hash过程） 

- **原理**：数据结构采用数组+链表+红黑树的方式，通过key的hashCode经过扰动函数处理后得到hash值，再通过（n-1）&hash找到元素的位置，若存在，则判断是否相同，相同覆盖，不同就采用链表处理冲突

- **扰动函数（hash函数）**：HashMap的hash函数，将hash值>>>16位后与原值异或，也就是高位和低位异或。避免hashCode函数性能较差，减少冲突

     `(h = key.hashCode()) ^ (h >>> 16)`，注意是逻辑右移，即移动后高位全为0，相当于高16和低16异或

- **链表变红黑树的条件**：当链表元素>=8（任意插入方法中判断），若HashMap容量<64就扩容（在`treeifyBin`方法中判断，而不是在外部判断），>64就变成红黑树

#### 扩容机制（阈值，rehash，头插法）

- **概述**：达到阈值`threshold`后，创建新容器扩容为原来的2倍，rehash重新计算节点的索引，将节点对应的链表或者红黑树移动到新容器中

     `(++size > threshold)`,`newCap = oldCap << 1`

- **rehash**：jdk1.8以后`(e.hash & oldCap) == 0`，原索引或者原索引+oldCap（旧容量）

- **插入新容器**：1.7头插法并发会产生死循环。1.8改为顺序插入

- **初始容量为16，加载因子为0.75**

- **扩容条件**：当达到容量\*加载因子（16\*0.75）时，扩容为原来的两倍

#### ConcurrentHashMap

- **存储结构**

 - **JDK1.7**：Segment数组+HashEntry数组，每个Segment类似于一个HashMap。在Segment上加锁。初始化数量后不可改变，最多16个。
     - **JDK1.8**：Node数组+链表+红黑树。对Node（链表红黑树的头节点）进行CAS和Synchronized同步加锁，锁粒度减小
     
- **并发扩容**：当扩容时不能进行读写操作，如果线程发现正在扩容，那么会调用`helpTransfer`方法帮助加快扩容

     其中使用`sizeCtl `变量用于标志正在扩容的线程数量，`ForwardingNode`类用于标识已转移的节点，其他线程访问到它时就会帮助扩容

#### 为什么容量为2的n次方

因为计算机的位运算比较取余等运算快（寄存器直接移位），这样可以提高查找索引位置（`(n-1)&hash`）以及移位扩容（`newCap = oldCap << 1`）的效率

#### HashMap，HashTable，ConcurrentHashMap区别

- **记忆**：初始容量（11，16）、扩容机制（2倍，2倍+1）、null值、线程安全的底层数据结构
- HashMap线程不安全，另外两个线程安全；
- Hahsmap初始容量为16，扩容为2倍，HashTable为11，扩容为2倍+1（`(oldCapacity << 1) + 1`）；
- HashMap的key和value均可以为null，其他不行；
- HashTable用Synchronized锁住整张Hash表，效率低；ConcurrentHashMap采用数据分段加锁 (细说底层如Segement数组)

#### 线程不安全原因

- **JDK1.7扩容采用头插法形成循环链表**
- **put操作可能丢失修改**（同时操作头节点，判断为null后修改覆盖）

## 异常

Java中的异常分为`Error`和`Exception`，其中`Error`是程序处理不了的，如内存不足、栈溢出等；`Exception`是程序可以捕获并进行处理的，如空指针、数组越界等。

`Exception`分为编译时异常和运行时异常，其中编译时异常需要捕获处理，否则编译不能通过

通过`throw`抛出异常，`try-catch-finally`捕获并处理异常

![](https://res-static.hc-cdn.cn/fms/img/14c709e083d859cca243d8a1052ad1c01603765256008.png)

## 反射

JAVA 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 java 语言的反射机制。

## 泛型

-    **是什么**：泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。

-    **实现**：Java的泛型是伪泛型，采用了类型擦除的方式，在实际的class文件中不存在泛型的类型信息

将泛型类型中的所有类型参数替换为**其边界**或`Object`（如果类型参数不受限制）。必要时插入**类型转换**，以保持类型安全。

-    **泛型类**、**泛型方法**：

     ```Java
     class  Test<T>{}
     public <T> T fun(){}
     ```

     泛型方法能使方法独立于类而产生变化，必要时都使用泛型方法

### 通配符?,T 

- ？和 T的区别：

  - T是可以操作的，比如在泛型类中用于声明变量类型；（T a可以，？ a不可以）
  - ？常用于不依赖于T的时候，即不需要使用类型的具体功能时，只使用Object类中的功能
  - List<?>是任何List<>的父类型


## 		static关键字

-    修饰方法、变量

​			表示属于类，多个对象共享。调用时直接用类名就行，不需要创建实例

-    修饰内部类

​			这个内部类独立与外围类，可以单独创建使用；不能使用任何外围类的非static变量

​		（QW.Q q = new QW.Q();）

-    修饰代码块

​			类的static代码块最先执行，只执行一次

-    import static

​			用于引入类的静态方法和成员，不用加类名就能直接使用

## 深拷贝、浅拷贝

-    **深拷贝**：对于基础数据类型，复制属性的值；对于引用类型，会分配一块新的内存创建对象。
-    **浅拷贝**：对于基础数据类型，复制属性的值；对于引用类型，只是拷贝引用，指向的内存还是同一块。
-    **实现方式**
     -    **浅拷贝**：Object的clone方法是native方法，是浅拷贝。需要实现Cloneable接口并重写clone方法（super.clone()）
     -    **深拷贝**
          -    这个对象必须要实现Cloneable接口，实现clone方法，并且在clone方法内部，把引用类型变量也要clone一份 ， 这就要求这个引用类型也要实现Cloneable接口并且实现clone方法。
          -    反序列化


# JVM

## JVM运行时内存区域



<img src="https://snailclimb.gitee.io/javaguide/docs/java/jvm/pictures/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F.png" style="zoom:50%;" />

- **程序计数器：** 通过改变这个计数器的值来选取下一条需要执行的字节码指令

	**它是唯一一个不会出现 `OutOfMemoryError` 的内存区域**（因为它只是保存下一条待执行的命令的地址）

- **Java虚拟机栈：**存放Java方法的参数，变量和局部变量等信息（栈递归，而且没有足够内存来动态扩展）

- **本地方法栈**：用于native方法使用（同上）  

- **堆**：存放对象实例和数组，GC的主要区域（内存无法分配对象）

- **方法区**：被虚拟机加载的类信息、常量、静态变量等（常量池过大，无足够内存）（1.8后变成了元空间，放在直接内存中）

## 内存模型（JMM）

Java 内存模型是一种规范，定义了很多东西：

-    所有的变量都存储在主内存（Main Memory）中。
-    每个线程都有一个私有的本地内存（Local Memory），本地内存中存储了该线程以读/写共享变量的拷贝副本。
-    线程对变量的所有操作都必须在本地内存中进行，而不能直接读写主内存。
-    不同的线程之间无法直接访问对方本地内存中的变量。

作用是屏蔽底层硬件和操作系统的内存访问差异，保证在不同平台可以实现一致的并发效果。

其中对于工作内存和主内存之间的交互规定了8种操作

- lock：主存变量设置为线程独占
- unlock：解锁
- read：主存变量传输到工作内存
- load：将上一步的变量放入工作内存的变量副本中
- write：相反
- store：相反
- use：将工作内存变量传递给执行引擎
- assign：将执行引擎的值赋给工作内存

**happens-before原则**：对于内存模型的有序性，JMM规定的两项操作之间的顺序关系，若A先于B发生，意味着A产生的改变对B可见

内存模型中天然具备的先行关系

- 同一线程内，逻辑顺序在前的代码先于在后的代码
- unlock先于后面对同一个锁的lock
- vatile变量的写先于后面的读

## 创建对象的五步

- **类加载检查：**检查常量池中是否有这个类的符号引用，并检查是否加载初始化过；若没有，执行类加载
- **分配内存**
	- **方法**
		- **指针碰撞法（内存规整）**：将内存分为已使用和未使用，用一个指针相隔，分配时就将指针移动指定大小
		- **空闲列表（内存不规整）：**维护一个可用列表，从列表中找出一块可用的内存
	- **并发问题**
		- CAS机制保证分配动作的原子性
		- （TLAB）每个线程预先在堆分配一块内存，给对象分配时就在每个线程自己的这块内存上分配，用完了再分配新的
- **初始化0值**：将分配的内存置0，以便能够直接使用
- **设置对象头**：包含GC分代年龄、hashCode、锁状态标志等信息
- **执行init方法**：对象构造器方法，初始化变量字段

## 对象内存布局

- **对象头**
	- **自身运行时数据（Mark Word）**：GC分代年龄、hashCode、锁状态标志等
	- **类型指针**：指向类元数据，表示它是哪个类的实例
- 实例数据
- 对齐填充：要求对象大小为8字节整数倍，对象头为8字节或16字节(取决于机器位数)

## 对象的访问方式

- **句柄**：在堆中分出一块内存为句柄，引用存的就是句柄的地址，句柄再指向实例
- **直接指针**：引用直接保存的就是实例地址

## GC垃圾回收

### 对象死亡判断的2种方法

- **引用计数法**

- **可达性分析**（图）：从GC ROOT向下搜索，若该对象不可达，则不可用；后判断是否有必要执行finalize方法（覆盖finalize方法或者已经执行过了）；若必要就二次标记，没有建立其他引用就回收；

	**GC ROOT**
	
	- **栈**：虚拟机栈、本地方法栈中引用的对象
	- **方法区**：类静态属性、常量引用的对象

### GC算法

- **标记-清除**：标记得是**不需要回收的对象**，然后清除没有标记的对象
     - 效率低、碎片化高
- **复制算法**：将内存分为两部分，每次使用其中一块，用完后就将存活对象复制到另外一块，然后清除。
     - 效率高
- **标记-整理**：标记后，将标记对象移动到另一端，清除边界以外的对象
- **分代收集**：将内存分代，然后采用不同的上述几种算法；**新生代-复制法**，**标记法**

### GC优化

- GC调优一般具体是通过**GC日志的情况来分析**。基本上发现minor gc频繁，新生代空间太小了。
- 如果发现晋升的年龄很小，老年代迅速被填满，导致频繁的major gc，并且回收比率又很大，那说明需要调整晋升年龄
- 如果看full gc很频繁，但是每次回收的内存就一点点，那目测就是内存泄露了。总体上就是根据分代的根本，也就是新生代朝生夕死的事实调整GC，避免分配大对象。

### 垃圾回收器

- 初代
     - Serial：单线程，需要停止用户线程
     - ParNew：多线程版本 
- 现行
     - **CMS**：注重用户体验，**以获取最短回收停顿时间为目标**。采用**标记-清除算法**
          - **步骤**
               - **初始标记**：停下其他线程，标记**直接与Root相连的对象**
               - **并发标记**：从Root记录可达对象，但由于用户线程在更新，没有实时性；
               - **重新标记**：修正上一步更新的记录（会停止用户线程）
               - **并发清除**
     - **G1**：面向服务器，**以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.**
          - **特点**
               - G1将堆分为多个Region，在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region
               - **并行与并发**：充分利用多CPU减少停顿
               - **分代收集**：G1保留了分代的概念
               - **空间整合**：整体是”标记-整理“，局部是”复制“
               - **可预测的停顿**：使用者可以明确指定GC时间

### Full GC（大对象进入）

- 回收堆、方法区
- 条件
	- **老年代空间不够**：新生代大对象、大数组转移
	- **方法区空间不够**
- 避免方法
	- 避免频繁的创建销毁大对象（单例模式）
	- 合理设置新生代的空间
	- 合理设置GC年龄

### 四种引用（强、软、弱、虚）

- **强引用**：不会回收
- **软引用**：内存不够回收
- **弱引用**：发现就回收（不管内存够不够）
- **虚引用**：跟没有引用一样，必须配合引用队列使用，用于跟踪对象回收的活动

### 无用的常量和类

- **常量**：没有String引用的常量会从常量池中回收
- **类**
	- 无实例
	- 无加载该类的ClassLoader
	- 无Class对象的使用

## 内存泄露的情况

- 集合类：比如List等放入一个对象，即使把这个对象引用置空，GC也不能回收，因为List还指向这块内存
- 连接资源：比如IO连接、数据库连接等，如果没有显示的close关闭的话，也不能回收

## 排查内存泄漏

- **初步判断**：频繁发生Full GC，但是回收的内存又很少
- **分析进程发生内存泄露的地方：**导出dump文件（jmap），分析对象的引用链，查看创建对象的代码是否可能存在内存泄露的可能

## 伪共享

CPU内有高速缓存，且分成了缓存行。当多个变量放在同一行，不同线程看似在操作不同的变量，但由于放在同一行会有竞争。
解决办法：字节填充，避免多个变量在一行

## Class文件结构（从类拥有的东西思考）

**总的记忆**：魔数、版本号、常量池、实现接口、字段、方法、属性

- **magic**（魔数）：开头的四个字节
- **大小版本号**
- **常量池**
- **字段表**
- **方法表**
- **本类和父类索引**

![](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E7%B1%BB%E6%96%87%E4%BB%B6%E5%AD%97%E8%8A%82%E7%A0%81%E7%BB%93%E6%9E%84%E7%BB%84%E7%BB%87%E7%A4%BA%E6%84%8F%E5%9B%BE.png)

## 类加载过程

### **加载**

- 通过全类名获取二进制字节流并转换为方法区的数据机构
- 在内存中生成Class对象作为数据访问入口

### **验证**

<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E9%AA%8C%E8%AF%81%E9%98%B6%E6%AE%B5.png" style="zoom:50%;" />

### **准备**

- 正式为类变量分配内存并设置类变量初始值的阶段，初始值除了final其余均为0（null）

### **解析**

- 将符号引用变为直接引用；

### **初始化**

- 执行字节码（主动使用类才会初始化）

### 类生命周期

​	<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B-%E5%AE%8C%E5%96%84.png" style="zoom:50%;" />

## 类加载器

### **BootstrapClassLoader(启动类加载器)** 

- 最顶层的加载类，由C++实现，负责加载 `%JAVA_HOME%/lib`目录下的jar包和类或者或被 `-Xbootclasspath`参数指定的路径中的所有类。

### **ExtensionClassLoader(扩展类加载器)** 

- 主要负责加载目录 `%JRE_HOME%/lib/ext` 目录下的jar包和类，或被 `java.ext.dirs` 系统变量所指定的路径下的jar包。

### **AppClassLoader(应用程序类加载器)**  

- 面向我们用户的加载器，负责加载当前应用classpath下的所有jar包和类。

## 双亲委派模型



<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/classloader_WPS%E5%9B%BE%E7%89%87.png" style="zoom:50%;" />

- 加载时将请求委派给父加载器，检查是否加载过。如果不能处理才由自己加载；总之**就是自底向上的检查是否加载过，自顶向下的尝试加载类**

- 优点
	- 避免类重复加载
	- 防止Java的API被篡改，比如用户自定义Object类，运行时出现多个Object类
	
- 例外情况：

	JDBC的加载直接使用了线程上下文的加载器，也就是AppClassLoader，而没有委托给上一级的加载器；
	
	因为JDK只提供接口，实现是由第三方提供的，上一级的加载器无法加载其他目录

## JVM参数

-    堆
     xms xmx;
-    栈
     xss

# 多线程

## Java线程状态

- New
- RUNNABLE--包括就绪和运行
- BLOCKED--等待锁
- WAITING--wait方法、需要其他线程唤醒
- TIMED_WAITING--超时等待 
- TERMINATED--结束



## 进程与线程的区别

- 进程是资源分配的基本单位、线程是调度的基本单位（**调度**）

- 进程单独占有内存空间地址及其他系统资源（如IO）（**资源**），通信复杂

	线程共享所属进程的内存地址空间和资源，通信简单

- 进程切换不仅需要保存寄存器和栈信息，还需要资源的分配回收、开销较大、线程只需要保存栈和寄存器开销小（**开销**）

### 协程

一个线程可以拥有多个协程，它的上下文切换由程序控制，与内核无关

## 创建线程的方法

- 继承Thread方法、重写run方法
- 实现Runnable接口的run方法
- Executor（线程池）
- Callable（有返回值）
  - **异步原理**：
    1. 通过submit提交Callable接口，内部会包装成RunnableFuture，实际上是FutureTask。通过excute执行，然后立即返回FutureTask对象
    2. 现在相当于FutureTask被两个线程共享
       - 一方通过调用get方法，会通过LockSupport.park阻塞线程直到任务完成
       - 另一方通过调用run方法执行任务，并将结果放入outcome变量中，然后通过LockSupport.unpark唤醒等待队列中的线程

## Callable、Future、FutureTask

- Callable:类似于Runable，不过它是可以带有返回值的
- Future：用于接收线程的返回结果，可以通过get方法来阻塞查看执行结果
- FutureTask：继承了Future和Runable两种接口，用作excute执行任务提交，并同时作为结果返回。让两个线程共享，实现阻塞和唤醒的异步过程

## Java线程4种通信方式

- 共享变量：使用volatile修饰的变量
- 等待/通知机制：wait、notify
- 管道：pipeReder
- 消息队列

## volatitle作用

- 保持**线程可见性**：一个线程修改了共享变量的值，其他线程能立即得知这个修改。（线程有私有本地内存，修改变量后刷新回主内存，但其他线程的私有内存并没有更新，还是使用的旧值。）
- 防止**指令重排序**:计算机在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排

## 并发三点特性（volatitle和synchronized）

- **原子性**：一个或多个操作执行过程中不被打断的特性
- **可见性**：一个线程改变了共享变量之后，其他线程能够立即知道这个变量被修改
- **有序性**：程序按照代码先后顺序执行

## synchronized锁升级（Java6以后）

- **无锁**
- **偏向锁**：（不需要锁和CAS）
	- **概念**：偏向锁会偏向于第一个访问锁的线程，如果在接下来的运行过程中，该锁没有被其他的线程访问，则持有偏向锁的线程将永远不需要触发同步
	- **升级**：若有新的线程，则尝试CAS更新，失败就升级锁
	- **获取锁**：第一次进入同步块时，会在对象头和栈帧中的锁记录里存储锁的偏向的线程ID，下一次检查锁的Mark Word里面是不是放的自己的线程ID
- **轻量级锁（自旋锁）**：
	- **概念**：通过自旋获取锁
	- **获取锁**：将MarkWord复制到自己的栈，然后尝试CAS更新MarkWord为指向此锁记录的指针，失败就使用自旋
	- **升级**：自旋次数过多，就升级。
- **重量级锁**
	- **概念**：依赖于操作系统的互斥量（mutex） 实现的，需要线程状态转换。

### 其他锁优化

- 适应性自旋：若有线程通过自旋获得了锁对象，那么自旋重试次数会增加（因为获得锁的几率比较大）；相反的话，就会减少自旋重试次数

- 锁消除：对于一段代码，若检测到堆上的数据不会逃逸出去而被其他线程访问到，那么可以把它视作栈上的私有数据不加锁；

	```Java
	public String concatString(String s1, String s2, String s3) {
	    StringBuffer sb = new StringBuffer();
	    sb.append("a");
	    sb.append("b");
	    sb.append("c");
	    return sb.toString();
	}
	```
	
	比如append方法内部有同步代码块，锁对象是sb，但是这个sb只能在concatString内部使用到，不会出现多线程的问题；就会忽略同步代码块

- 锁粗化：多步零散操作进行多次加锁，会优化成首尾加一次锁，比如上述代码。

## synchronized底层实现

JVM基于进入和退出monitor对象来实现方法和代码块同步

- **方法**：隐式，无需字节码指令；

	调用方法时检查标志是否为同步方法，尝试持有monitor对象
	
	返回时释放对象

- **代码块**：通过monitorenter和monitorexit两个字节码指令

	分别位于开始和结束的位置
	
	monitorenter指令执行尝试获取锁，计数器+1
	
	monitorexit指令执行计数器-1，变为0就释放

## 乐观锁与悲观锁

- **乐观锁**：数据操作不加锁，只在最终更新数据的时候才检验当前数据是否被修改过，也就是CAS操作
- **悲观锁**：数据操作之前需要加锁，完成后释放锁

## JUC包下的类（lock、线程池、同步工具）

- 原子类：如AtomicInteger
- lock接口实现类：如ReentantLock、ReentrantReadWriteLock
- 同步工具：如CountDownLatch（CDL）
- 并发容器：如ConcurrentHashMap
- 阻塞队列：ArrayBlockingQueue
- 线程池

## 原子操作

- 要么执行完所有步骤，要么一步也不执行，不可能只执行所有步骤的一个子集的一组操作
- **CAS**：
	- 比较并交换，是一种不需要加锁就能完成原子操作的技术；判断要修改的变量是否等于预期值，等于就更新值；不等于则说明变量被其他线程修改过了，此次操作失败，重新进行操作，不会挂起
	- ABA问题：一个值原来是A，变成了B，又变回了A。这个时候使用CAS是检查不出变化的，解决方法是变量加版本号或时间戳
	- 缺点：ABA、循环消耗CPU（循环一定时间后睡眠），只能共享一个变量
- **Atomic类**

## AQS（Lock的底层实现）

- 抽象队列同步器，提供了一种实现阻塞锁和一系列依赖FIFO等待队列的同步器的框架

- **数据结构**：volatile变量state，双向链表（等待队列）

- **资源共享模式**：独占式、共享式

- **主要方法**：

  - aquire：先调用tryAquire设置state值，然后根据返回值决定是否放入**阻塞**队列然后挂起
  - release：先调用tryRelease设置state值，然后根据返回值决定是否**唤醒**队列中的线程

  **概述**：1. 真正设置state值的是`try系列`方法，为抽象方法，由子类具体实现决定state的值代表的含义。

  2. 不带try的是根据相应的值决定是阻塞还是唤醒。

## 线程同步器工具类

### CountDownLatch

用于主线程等待多个子线程执行完毕，一次性不可复用

主线程`await`，子线程`countdown`减少state值

主要通过`CAS`操作来减少state值

### CyclicBarrier

与`CountDownLatch`类似，不过可以复用。且通过`ReentrantLock`来减少计数器

各个线程执行完一阶段逻辑后调用`await`方法阻塞，当计数器为0后会调用传入的`Runable`执行汇总，并恢复计数器然后唤醒线程开始下一阶段任务。

### Semaphore

计数器是递增的，通过`CAS`操作。

`release`增加state，`aquire(n)`获取n，也就是减少n。且`aquire`分为公平和非公平，也就是先`aquire`

## 线程池

### 创建方式

- **ThreadPoolExecutor**：提供7大参数自定义
- **Executor**：创建特定的线程池，如4种常用的线程池

### 组成

- **线程管理池**：负责线程池的创建销毁等
- **工作线程**：循环执行任务，没有任务就等待
- **任务接口**：每个任务需要实现任务接口供工作线程调度，规定了任务的入口，收尾状态等
- **任务队列**：存放等待执行的任务

###  **使用原因**

  - 创建/销毁线程需要消耗系统资源，线程池可以**复用已创建的线程**。
  - **可以对线程做统一管理，控制并发的数量**。并发数量过多，可能会导致资源消耗过多，从而造成服务器崩溃。（主要原因）

### **状态**

  - RUNNING
  - SHURDOWN
  - STOP
  - TIDYING：所有任务终止并且任务数为0
  - TERMINATED

### **ThreadPoolExecutor的5大参数**

  - corePoolSize：核心线程的最大值（核心线程默认会一直存在，非核心闲置过久会销毁）
  - maximumPoolSize：最大线程数
  - keepAliveTime：非核心线程闲置时间
  - TimeUnit：keepAliveTime的单位（毫秒、秒等）
  - BlockingQueue ：存储着等待执行的Runable任务对象
	- LinkedBlockingQueue
	- ArrayBlockingQueue
	- SynchronousQueue（put和take操作）
	- DelayQueue

### **ThreadPoolExecutor的2个非必要参数**

  -  threadFactory：设置一些参数，如守护线程等
  -  RejectedExecutionHandler：拒绝处理策略

### **拒绝处理策略（超出最大线程数后）**

  - 默认-丢弃任务并抛出异常
  - 只是丢弃任务
  - 丢弃队列头部并重新尝试执行，若失败再次重复
  - 交给调度线程处理

### **任务提交后执行流程**

  - 线程数 < corePoolSize,新建核心线程执行，以便快速达到corePoolSize
  - 线程数>=corePoolSize，进入等待队列，空闲的核心线程会依次去缓存队列中取任务来执行
  - 队列满了后新建非核心线程
  - 达到maximumPoolSize后执行拒绝策略

## 核心线程和非核心线程

- 核心线程和非核心线程都会去阻塞队列中获取任务，不过核心线程调用take方法，会阻塞直到有任务；非核心线程会调用poll（time），超时就结束

### **复用**

- 完成任务后会循环的从队列中取出任务来执行而不是销毁，如果没有任务执行就阻塞

### **4种提供的常用线程池**

  - CachedThreadPool：只有非核心线程，线程池数量多（Integer.MAX_VALUE，2的31次方-1），适合短时间任务
  - FixedThreadPool：只有核心线程，缓冲队列长；没有任务的情况下， FixedThreadPool占用资源更多
  - SingleThreadExecutor：单一核心线程，通过先来先服务执行任务
  - ScheduledThreadPool：定长线程池，支持定时及周期性任务执行

## 并发容器

- ConcurrentHashMap
- ConcurrentLinkedQueue、ConcurrentLinkedDeque（List的替代品，CAS操作）
- ConcurrentSkipListSet
- CopyOnWrite容器

- 阻塞队列
  - **定义**：提供了线程安全的队列访问方式

  - **原理**

    通过``ReentrantLock``进行加锁，通过``notFull``和``notEmpty``两个条件变量作为两个等待队列，对于``put``若满了就``notFull.await()``,对于``offer``就直接返回失败。入队和出队分别调用``enqueue,dequeue``,调用相应条件变量的``signal``方法唤醒

    - take和put是阻塞的获取和存储元素的方法，

      poll和offer是不阻塞的获取元素和存储元素的方法，并且poll和offer可以指定超时时间。

      add和remove存取元素，队列满时add抛异常，队列空时remove抛异常

  - **类型**
    
    - **有界**
    	- ArrayBlockingQueue：初始化容量后不能改变，基于数组
    	- LinkedBlockingQueue：容量为Integer.MAX_VALUE。线程池的使用队列
    - **无界**
    	- DelayQueue：在一定延迟后才能取数据
    	- PriorityBlockingQueue：内部采用公平锁
    	- SynchronousQueue：put后必须take，否则阻塞等待，反之亦然；
    

## 锁的接口和类（Lock）

- **与synchronized区别（层面、锁释放、中断、判断）**
	- synchronized是关键字，字节指令实现；Lock是接口，实现类底层用CAS实现
	- synchronized异常会释放锁，Lock需要在finally中释放
	- synchronized不可中断，不能判断锁状态
	- synchronized功能单一，Lock提供更多个性化		
- **接口Lock的实现类**
	
	- ReentrantLock：默认实现，包括公平（FIFO）和非公平
	- 公平与非公平实现方式：
	  - 公平锁会通过``hasQueuedPredecessors``方法判断等待队列中是否有节点，若有节点且头部节点不是当前线程，那么获取锁失败，当前线程入队
	  - 非公平锁不会判断等待队列中是否有节点，而是直接通过CAS尝试获取锁。很可能先于等待队列中的节点获取到锁
- **ReadWriteLock接口**
	
	- ReentrantReadWriteLock：读写锁，可以返回读锁和写锁
	
	  高16位代表读锁state，低16位代表写锁
	
	  在非公平锁情况下，允许写锁插队，也允许读锁插队，但是读锁插队的前提是队列中的头节点不能是想获取写锁的线程。避免线程饥饿
- **StampedLock**：比读写锁性能更好，在读的时候如果发生了写，应该通过重试的方式来获取新的值，而不应该阻塞写操作。（CAS自旋） 

## 中断

- 方法

     | public static boolean interrupted  | 测试当前线程是否已经中断。线程的中断状态 由该方法清除。换句话说，如果连续两次调用该方法，则第二次调用将返回 false（在第一次调用已清除了其中断状态之后，且第二次调用检验完中断状态前，当前线程再次中断的情况除外）。（相当于线程响应了一次中断，自然要将它置为false） |
     | ---------------------------------- | ------------------------------------------------------------ |
     | public boolean **isInterrupted**() | 测试线程是否已经中断。线程的**中断状态**不受该方法的影响。   |
     | public void **interrupt**()        | 中断线程，将**中断状态**设置为true。                         |

- 响应中断：线程内部通过判断中断状态决定下一步的操作，一般是停止执行并退出

## ThreadLocal

每个线程Thread中有一个map，我们创建一个ThreadLocal变量来操作线程中map，比如set/get。key是ThreadLocal变量（this)的弱引用（一gc就会回收），value是保存的变量值

- key设计成弱引用的目的

  为了更好地对ThreadLocal进行回收，当我们在代码中将ThreadLocal的强引用置为null后，这时候Entry中的ThreadLocal理应被回收了，但是如果Entry的key被设置成强引用则该ThreadLocal就不能被回收

- value设计成强引用

  因为value是用户需要使用的值，如果在key还没生效时就被回收了显然是不对的；若key被回收变成了null，那么说明这个键值对就是无效的了，应该删除掉（或者在map进行扩容时会自动清除失效的键值对）

**内存泄漏相关问题**

- **key泄漏**：``ThreadLocalMap``的key是弱引用，一旦内存不够gc就能回收
- **value泄漏**：value引用是强引用，随着线程的结束会释放。但是如果线程运行时间很长，但ThreadLocalMap又不使用了的话，就会造成内存泄漏。所以不再使用了的话要手动调用remove方法释放

# MySQL

## mysql的执行过程

客户端建立连接后发送sql，服务端经过连接器检查连接，然后查询缓存，如有就直接返回。然后依次经过分析器、优化器、执行器、存储引擎

## sql注入和预编译

将恶意sql作为参数代码发给服务器，服务器没有**合法校验**，会错误识别的执行sql

解决办法是对sql进行预编译，做一些过滤优化。然后动态的传入参数 ，这样只会把恶意sql识别为参数，而不会当作sql语法执行

## MyISAM和InnoDB区别

- 行级锁（针对索引加锁）
- 事务以及事务安全性操作，如崩溃后的安全恢复
- 外键
- MVCC-多版本并发控制：用于高并发，写的时候会添加一个新的版本而不是修改，所以不会影响读

**实现**：每列有隐藏字段，标识事务id、指向undo log的指针；事务开启时候会有一个版本号进行比对

![https://mmbiz.qpic.cn/mmbiz_png/55HPQyguvpMjiaoJ2Quu9UPMoKdX5z9aufArozcWViaT8FVNLkxrWmEXYlpjkZdWP8hhshiaHttEmicuv87g1q0Yxg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1](https://mmbiz.qpic.cn/mmbiz_png/55HPQyguvpMjiaoJ2Quu9UPMoKdX5z9aufArozcWViaT8FVNLkxrWmEXYlpjkZdWP8hhshiaHttEmicuv87g1q0Yxg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

**版本链比对规则：**

1.   如果落在绿色部分（trx_id<min_id），表示这个版本是已经提交的事务生成的，这个数据是可见的；
2.   如果落在红色部分（trx_id>max_id），表示这个版本是由将来启动的事务生成的，是肯定不可见的；
3.   如果落在黄色部分（min_id<=trx_id<=max_id），那就包含两种情况：a.若row的trx_id在数组（未提交的事务会保存在数组）中，表示这个版本是由还没提交的事务生成的，不可见；如果是自己的事务，则是可见的；b.若row的trx_id不在数组中，表示这个版本是已经提交了的事务生成的，可见。

## 事务

### 	定义

​	一系列逻辑操作，要么全部执行，要么都不执行，不允许完成部分

### 	四个特性（ACID）

- 原子性（Atomicity）：操作只能全部完成，不能部分（`undo log`）

- 一致性（Consistency）：数据从一个正常状态变为另一个正常状态 (`AID都是为了C`)

     违反举例：A有200元，转账给B。无论如何，A、B加起来都必须满足200元，而不会出现其他状态

- 隔离性（Isolation）：事务执行不能被其他事务干扰，互相隔离 （`锁机制、MVCC`）

- 持久性（Durability）：事务正确完成后，数据的改变是永久性的 （`redo log`）

### 并发事务的4个问题

- 脏读：一个事务读取了另一个事务还没有提交的数据
- 丢失修改：两个事务同时访问数据，一个修改了数据，另一个也修改，那么第一个的修改就丢失了
- 不可重复读：一个事务重复读取，但数据不一致，因为途中另一个事务修改了数据
- 幻读：一个事务读取了几行数据，另一个事务插入了几行，刚才的事务再读的时候会发现多了一些原本不存在的数据

### 隔离级别

- read uncommitted：读取未提交
- （RC）read committed：读取已提交--解决脏读  （实现方式是MVCC）
- （RR）repeatable read：可重复读--解决不可重复读 （MVCC+Next-key lock）
- serializable：可串行化--解决幻读 

1. RC和RR一般来说可以通过加锁来解决，但频繁加锁会影响效率，InnoDB使用了MVCC机制的快照读的方式，解决了RC和RR的问题

2. Mysql默认支持repeatable read级别，但独特地只用了Next-key lock锁，因此可以避免幻读的产生，使得其达到了ACID的要求

3. **Next-key lock**：行锁和间隙锁的组合，查询时带有非唯一索引时，会锁住索引本身记录和它的间隙；若为唯一索引，会变为行锁（因为唯一索引就决定了查询时只有一条记录）

4. 间隙锁死锁问题

   A，B两个事务分别更新锁定一个范围，然后尝试插入对方锁定的范围，就会互相等待出现死锁

## redo、undo、binlog

- `redo log`：物理日志。对物理页面的修改会写入redo log，然后刷新到磁盘。用于数据库crash后的数据恢复。保证`持久性`
- `undo log`：逻辑日志。保存了事务发生之前的数据的一个版本，用于事务回滚和MVCC的实现。保证`原子性`
- `binlog`：逻辑日志。保存更新操作的自身逻辑，用于基于时间点恢复数据和用于主从复制

|       redo log       |              binlog              |
| :------------------: | :------------------------------: |
|      基于InnoDB      |            基于mysql             |
|    用于宕机后恢复    | 基于时间点恢复数据。用于主从复制 |
|     刷新时机不定     |     事务提交时立即刷新到磁盘     |
| 循环写，日志空间固定 |         追加写，不会覆盖         |

## 索引

### 分类

- 逻辑上：普通索引、主键索引、唯一索引、全文索引、组合索引
- 数据结构上：B+树，哈希索引
- 物理上：聚簇索引、非聚簇索引

### 最左匹配原则

联合索引从最左边的列开始匹配，直到遇到`>`、`<`、`%`等结束

**原理**：B+树构建索引时，依次从左到右对字段进行排序构建。

### 覆盖索引

有联合索引(a,b,c)，查询select a,b,c from table where a=..，select的列和索引刚好一样，就是覆盖所引。

这样避免了回表查询，因为在叶节点就能查到索引值 

### 回表

查询非聚簇索引需要再到聚簇索引中去查询数据记录，叫做回表

### 为什么采用B+树

- 非叶子节点只存储指针，叶子节点存储数据。能存储的数据更多，查询时间复杂度稳定在logN
- 叶节点用链表连接，更好地利用局部性原理；天然有序，更适合区间查询、排序、全表扫描等
- Hash没有顺序，不能区间查询和排序，重复键多的情况发生碰撞，效率降低

#### 相较于B树

因为 B 树不管叶子节点还是非叶子节点，都会保存数据，这样导致在非叶子节点中能保存的指针数量变少（有些资料也称为扇出），指针少的情况下要保存大量数据，只能增加树的高度，导致 IO 操作变多，查询性能变低

#### 相较于Hash

-    Hash没有顺序，不能区间查询和排序，重复键多的情况发生碰撞，效率降低。hash适合等值查询

### B+树层级和数据量

innodb最小存储单元为一页16k，也就是一个节点为一页。
非叶子节点存储索引指针，8字节+6字节。所以指针数为16384/14＝1170
叶子节点一行记录为1k，所以有16行。
存储的数据有1170*16。

多层就是1170*1170

所以一般B+树高1-3层，IO次数1-3次。就能存储千万级别的数量。生产环境一般为3-4层

### InnoDB物理组织结构

B+树非叶子节点存储索引页   

&dArr;

叶子节点存储数据页（16KB、双向链表）  

&dArr;

页内按条数进行分组，记为槽。槽保存了每组的最大地址, 槽内记录通过**单向链表**相连。通过二分查找找到槽，再遍历链表

**主键有序**：因为一页存满了会进行页分裂。如果在页中间插入数据，那么分裂的时候可能下一页也满了，引起连锁反应，影响效率。

### 聚簇索引

- 该索引中键值的逻辑顺序决定了表中相应行的物理顺序，找到索引的同时找到数据
- InnoDB将主键组织到一颗B+树，叶子节点存放数据
- 辅助索引：存放非主键，叶子节点存放主键，二次查找后找到数据

### 非聚簇索引 

- 该索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同，索引和数据分开放，索引结构的叶结点存放数据的地址
- MyISM使用，两颗B+索引树，存放主键和辅助键，叶节点都存放数据的地址

## 读写分离（主从复制）

采用一主多从，主节点用于写，从节点用于读。主从通过复制进行同步

-    同步延迟如何解决？

     对于必须读取最新数据的请求，强制读主库

-    同步如何实现？

     主节点启动一个线程将用于发送binlog内容

     从节点启动两个线程。一个用于IO接收binlog并保存在本地的relay-log；一个用于执行relay log的SQL

## 主从模式-binlog（3种）

-    **STATEMENT模式（SBR）**

     记录每条SQL语句

     日志量少、但会出现主从不一致的情况

-    **ROW模式（RBR）**

     记录修改的内容

     日志量大、不会出现不一致

-    **MIXED模式（MBR）**

     以上两种混合。一般采用`STATEMENT模式`，对于无法复制的操作采用`ROW模式`。

## 分库分表

-    **分库**

     时机：单个数据库占用空间很大、单个应用并发太大

     方式：如根据不同服务将用户表和订单表分别放在两个不同的数据库中。

-    **分表**

     单表数据量达到千万级别，读写速度缓慢

     -    **水平切分**

          将一张行比较多的表拆成多张表保存

     -    **垂直切分**

          一张表列比较多，可以把一些列单独抽出来作为一张表

-    引发的问题

     -    自带的事务机制无法满足不同数据库
     -    不同数据库无法Join
     -    分布式id（主键唯一）

     需要人为地封装很多操作
     
-    衍生问题：分库分表后，可以拆分服务为微服务，通过PRC等进行微服务调用

## 不重复的自增主键（分布式id）

-    单独用一个mysql实例来生成主键

-    Redis的incr命令

     RDB持久化可能会重复id、AOF不会重复但恢复时间长

-    雪花算法：使用时间戳、机器id等生成Long类型的ID

## SQL优化

- 最大化利用索引（避免不走索引的情况）

	- ##### 索引不生效的情况

		- 运算：字符串替换、加减运算、 函数转换
		- 以%开头的like
		- 联合索引不包含最左边的索引

- 尽可能避免全表扫描（加上限定范围）

  - 尽量避免使用 in 和 not in，可用between和exists代替
  - in查询搜索子查询内表，exist查询外表。not in不会使用索引，not exist可以使用索引

- 减少无效数据的查询（加上限定范围）

## 判断慢查询

-    **定位**

     -    开启慢查询日志、设置阈值
     -    `show processlist`：有时慢查询正在执行，已经导致数据库负载偏高了，而由于慢查询还没执行完，因此慢查询日志还看不到任何语句。此时可以使用 show processlist 命令判断正在执行的慢查询。

-    **分析**

     **Explain查看sql执行效率**

     explain SELECT * FROM `stock_order` WHERE id='1874'

     其中的type列可以查看是否使用了索引（一般为const使用了主键），至少要为range级别以上才不会出现性能问题

     -    **type**：连接使用了何种类型，`const`（使用主键查询一列），`range `(索引范围查询)、`index `(索引扫描)、`all`（全表扫描）、
     -    **possible_keys**：可能使用到了的索引
     -    **key**:实际使用的索引

     -    **key_len**：索引长度

## Join和Union

join是将两张表条件相同的部分记录产生一个记录集

union是两张表（字段一样）并在一起，产生一个新的记录集

# Redis

## 客户端到服务端的过程

服务器使用redisClient结构保存连接的客户端信息，保存在一个链表中进行处理

1. 用户键入命令，客户端将命令转换成协议格式通过网络连接发送
2. 服务器收到数据后读入客户端状态的输入缓冲区，并解析命令
3. 根据命令参数去字典中搜索相应的处理函数并保存在客户端状态的属性中
4. 通过客户端状态中的属性执行命令并将结果保存客户端状态的输出缓冲区
5. 通过网络连接回复结果。

## 数据结构

- **list**：双向链表
- **set**：hashTable
- **zset**：比set多了一个score参数，可用于排序
- **hash**：hashTable
- **string**：字符串键值对、动态字符串

​	**跳表**

- **原理：**跳表是一种维护了多层链表的数据结构，最低层拥有所有元素，每上一层是下层的子集。查找时不断缩小区间，可以达到二分的效果，而且插入删除也只会进行局部操作
- **删除**：从最高层依次向下搜索，一层一层的删除节点
- **插入**：1.先查到该节点，然后在最低层插入。2.是否向上一层插入可以通过**随机值**来确定。3.其中可以通过栈来记录**查找路径**，保证可以找到上一层节点

## 缓存穿透、击穿、雪崩

- **缓存穿透**
	- 大量请求的 key （一定不存在）根本不存在于缓存中，导致请求直接到了数据库上，根本没有经过缓存这一层
		- 解决：**布隆过滤器**或者缓存空值，设置过期时间很短
	
	- **布隆过滤器**：位数组，用K个hash函数计算key得到多个位置，将位数组中对应位置置为1，若查询不存在就一定不存在，若存在可能几率误判
	
- **缓存击穿**：**某个key**失效，大量请求同时到来
	- 解决：利用redis设置互斥锁，获取不到锁的线程就等待缓存值被写入，重新尝试查询缓存值

- **缓存雪崩**：同一时刻**多个key**大面积失效或者**redis宕机**，导致请求全部到了数据库
	- 解决：集群缓存+基础时间上加上一个随机时间+限流降级等

## 3种过期键删除策略

​	redis采用后两者

- 定时删除：设置定时器到点删除。易占用过多CPU时间。
- 惰性删除：只在查询key的时候才会检查是否过期，若过期就删除。易占用过多内存，过多过期键未删除。
- 定期删除：每隔一段时间扫描数据库删除过期键

## 缓存淘汰策略（3*2种）

![](https://pic2.zhimg.com/80/v2-bb57a78a0d780a0301a77e4280c3c67d_720w.jpg)

种类有：ttl、random、lru

-    volatile-ttl：表示在设置可过期时间的键值对中，根据过期时间的先后进行淘汰数据，越早被过期的数据，越先被淘汰。
-    volatile-random：从名字可以看出来，就是在设置了过期时间的键值对中，随机淘汰数据。
-    volatile-lru：会根据 lru 算法进行数据的淘汰
-    allkeys-random：在全部的键值对数据中，进行数据的随机淘汰。
-    allkeys-lru：在全部的键值对数据中，根据 lru 算法进行数据的淘汰。
-    allkeys-lfu：在全部的键值对数据中，根据 lfu 算法进行数据的淘汰。

## 3种缓存读写策略（缓存一致性）

- **Cache-Aside**：读缓存，没有就读db，写入缓存；写db，删除缓存

     读写策略一般采用cache side，更新数据的时候，**先更新数据库，再删除缓存**。还可以设置过期时间还保证最终一致性。
     删除缓存的原因，频繁更新缓存的计算成本大得多，而且不一定用得上。所以直接删除，当需要使用的时候再重新计算。

     详解：https://mp.weixin.qq.com/s/ODVdqLL81O-_dv_cmb9HkQ

     -    更新数据库，再删除缓存
          (缓存操作时间很快，失败几率小。可以设置过期时间保证最终一致性)
     -    删除缓存，更新数据库
          还没更新数据库就读取缓存。导致缓存和数据库不一致。
     -    更新数据库，再更新缓存。
          第一个还没更新完，第二个就更新完成。

     -    延时双删
          先删缓存，再更新数据库，延时，再删除数据库。
          延时：为了让其他事务完成更新操作

- **Write/Read-Through**：与上面类似，区别是程序**只跟缓存打交道**，读写db交给缓存去做。write适用于频繁读取，不能忍受数据不一致

- **Write-Behind**：与上述区别是不会立即写入数据库，而是**异步方式**

## 分布式锁

-    单机版：使用`set(key, value, NX, PX(毫秒)/EX(秒), time)`.使用包含多个参数的set命令，参数包含key，value，NX，PX（时间单位）、time

- 集群版

	使用RedLock ，即

	- 从多个节点中去获取锁

	- 若获取到超过半数的锁且所用时间小于失效时间就成功

	- 如果获取锁小于半数或者所用时间超过了失效时间，那么就对所有节点进行解锁（只会解除自己上的锁）
	
		，因为可能上锁成功但是超时没响应了。
	
- zookeeper实现

     创建临时节点---获取所有子节点---比较大小，判断是否最小---若是，获取成功；若不是，则监听最小节点，待释放后就再次获取

     

     zk实现思路是通过它的临时有序节点来实现。要获取分布式锁的线程，各自在一个node下创建一个临时有序节点，然后在获取该node下所有的子节点，然后比较自己所创建的节点是否是最小的。如果是最小的，则获取锁成功；如果不是最小的，则获取锁失败。此时还需要监听(watch)比它小的一个节点，这样当比它小的节点失效后，它能及时获得通知，然后在重新检查自己是否当前子节点中最小的。其实这种方式相当于一个分布式队列的形式实现的公平锁。由于zk本身可以保证一致性，可用性也只会在zk选举的时候少量时间不可用，是大部分业务可以接受的。所以我一般推荐分布式锁使用zk来实现。

## 主从、哨兵、集群

- **主从复制**：从节点发送同步命令，主节点执行BGSAVE命令生成RDB文件，并在缓冲区中存储后面执行的命令

	然后将rdb文件发给从节点，可以达到执行命令时的状态；再把缓冲区中的命令发给从节点（这是执行复制过程中产生的命令）

- **哨兵模式**：哨兵每秒发送ping命令监测主从节点，若超出一定时间，则判定为主观下线。并会询问其他哨兵，若多个哨兵同意，那么该节点就变为客观下线。多个哨兵之间选选举领头哨兵后，进行故障转移。（不同哨兵的配置不同，即同意下线的哨兵个数可能不同）

- **集群**：多个节点存储不同的数据。redis将一个集群分为多个槽（16384，2^14），将槽分配到一定的节点中，在槽中存储数据。通过对key进行crc16计算得到值后，再对16384取余得到槽编号（`函数CRC16（16）&16383`）。然 后找到槽对应的节点就能读取数据。每个节点都存储了所有槽和节点的对应关系，连接一个节点就能知道整个集群的信息。

  - crc16可以达到65536个槽，但redis只采用了16384个。因为节点和槽的信息用bitmap表示，16384需要16384/8=2k的空间，而65535需要65536/8=8k，占用空间过大。根据作者的观点，redis理论上最多有1000个节点（更多的话就会网络拥堵），16384个槽是完全够用的，没必要扩展到65536

## 高效率的原因 

- 单线程免去上下文切换
- IO多路复用
- 基于内存

## 持久化机制

- **RDB**：每隔一段时间将数据存储到磁盘上，恢复时直接复制。好处是存储量小，恢复速度快。坏处是时间间隔比较长，会丢失一部分数据
- **AOF**：每秒将执行的所有命令存储到磁盘上，恢复时重新执行一遍命令。好处是时间间隔比较小，最多只会丢失1s的数据。坏处是存储量比较大，恢复速度慢

## BIO、NIO、AIO区别

- 同步阻塞：数据的读取写入必须阻塞在一个线程内等待其完成。（水壶烧水比喻：一个线程只能等待一个水壶）

- 同步非阻塞：不断轮询**多个IO**的状态，然后执行（多个水壶）（通过选择器来选择）

  通过selector来接收连接，然后交给work线程执行任务。不必等待任务完成，selector又立马可以接收新的连接，这对于用户来说就是非阻塞的

- 异步非阻塞：通过回调函数来确保读写准备好了之后进行读写

- 同步异步、阻塞非阻塞：同步异步是调用者能否立即得到结果，阻塞非阻塞是程序等待调用结果的状态（挂不挂起）

### **NIO**

- **缓冲区Buffer**：所有数据通过缓冲区处理，保存读写数据
- **通道Channel**：通过它来读取和写入数据，和流的区别是它是全双工
- **多路复用器Selector**：监听多个通道的状态，决定是否操作

### IO多路复用

一个线程管理多个IO请求，通过OS的系统调用支持

- **select**
	- 每次调用`select`需要将需要监听的`socket文件描述符`（通过accept获取）传入，然后内核会先轮询一遍，如果没数据就会将`进程`从`可运行队列`中拿出放入socket的`等待队列`。当数据到来后会产生中断，中断处理程序就会唤醒`进程`。即清除等待队列，然后放入`可运行队列`
	- **概述**：传入fd集合 ---->  将进程放入socket等待队列阻塞  --->   中断唤醒进程    ---->     用户进程从select返回，轮询fd查看值

- **epoll**
	- 首先`epoll_create`创建epoll数据结构（包含`监视列表（红黑树）`、`就绪列表（双向链表，evenpoll）`、等待队列（进程））。然后`epoll_ctl`向监视列表中添加fd，将epoll对象放入socket的等待队列。调用`epoll_wait`阻塞等待`就绪列表`中有数据。数据到来后中断处理程序会将将socket放入就绪列表，然后唤醒epoll等待队列中的进程。
	- **概述**：创建epoll对象 ----> 添加监视fd ----> 调用epoll_wait阻塞等待 ----> 中断将socket放入就绪列表，唤醒进程 ----> 用户进程从epoll_wait返回并轮询得到的就绪列表


### **内核空间**

内核空间拥有更大的权限，可以访问底层硬件比如IO等资源

用户空间访问IO等资源需要通过进入内核空间来执行，而不是直接调用资源

**进入方式**

- 系统调用
- 异常
- 外围设备中断

# 设计模式

## 工厂模式

工厂模式中，创建对象不会对客户端暴露逻辑，而是向工厂类指定所需对象，由它完成创建，并可以用一个共同的接口指向所创建的对象。

## 单例模式

这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式。

# 分布式理论

- **CAP**：C-一致性，A-可用性，P-分区容错性。分布式系统中通过网络进行通信，但由于网络传输的不可靠，所以分布式系统必须保证分区容错性。当网络出现分区，那么C和A只能保证一个。因为要保证可用性，那么某个节点挂掉后继续运行就会导致数据的不一致。
- **BASE**：基本可用性-软状态-最终一致性。当系统出现分区，那么只能保证基本的可用性，比如响应时间，功能种类等会打折扣。软状态就是允许不同数据副本之间有延时，而不是随时保持强一致性。最终一致性就是软状态不能一直存在，必须保证最终能够读取到最新的数据，保持数据的最终的一致。

# Kafka

## 高吞吐量的3个优化

- **顺序读写**:kafka每个patition对应多个小文件，消息到来时就追加写在文件末尾。因为磁盘顺序读写速度快得多

- **零拷贝**：

	- **概念**：指计算机操作的过程中，CPU 不需要为数据在内存之间的拷贝消耗资源。而它通常是指计算机在网络上发送文件时，不需要将文件内容拷贝到用户空间（User Space）而直接在内核空间（Kernel Space）中传输到网络的方式

	- **实现**
		- **mmap**：将文件映射到内存，不用复制到用户空间就能进行操作
		- **sendfile**：将磁盘数据读入内核缓冲区后，不通过用户空间，直接发送到NIC缓冲区通过网络发送出去。（省去了socket缓冲区这一步，而是直接给NIC一个指针和偏移量）

- **Page Cache**：`producer`生产消息到`Broker`会先写入`page cache`，然后`Broker`使用`sendfile`将数据发送出去。`page cache`的数据会随着`flusher`额线程的调度写回磁盘。若生产和消费速率相当，那么数据读写几乎都在`page cache`中完成，磁盘访问非常少。

## 消息丢失

- **发送端**：使用带回调函数的send方法发送消息
- **kafka**：设置acks=all，保证所有副本接收后才算成功，避免 Kafka丢失消息
- **消费端**：关闭自动提交offset，手动提交offset，避免消费端消息丢失

## 顺序消费

Kafka只能保证单个的partiton之间的顺序消费。所以只需要保证消息发送到同一个partiton就能实现顺序消费。

一般可以指定单个partiton或者指定消息的key，相同key的消息会发送到同一个partiton。

## 消息队列作用

- 异步
- 解耦

## 简介

kafka是一个分布式流式处理平台，一般用作消息队列和日志数据处理。

## 选择原因

- 拥有较少的核心功能，但提供了极高的并发量。采用分布式架构，以及多副本机制，保证了可用性与可靠性。

## 特点

- 快速持久化
- 高并发量
- 分布式系统：Broker、Producer和Consumer都原生自动支持分布式，自动实现负载均衡；

## 消息模型

- **点对点**：生产者发布一条消息，只能有一个消费者消费一次。
- **发布-订阅**：使用topic作为消息载体，发布者发布一条消息，订阅topic的消费者均可以消费，没有订阅的就不会接收到消息

## Broker、Topic、Partition

- **Broker**：kafka集群中的一个服务节点，可以看作一个kafka实例
- **Topic**：消息的载体，发布到特定的topic，消费特定的topic
- **Partition**：每个topic有多个partition分区，可以存放在不同的broker，实现负载均衡

# Zookeeper

它是一个分布式管理框架，提供服务注册、管理等工作

- Broker、topic的注册、管理
- partition存放在不同的broker，它负责记录它们之间的关系。并尽可能的将partition存放在不同的broker上，实现负载均衡

  ​    
