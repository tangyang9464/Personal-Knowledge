#  一、进程管理

## 进程描述符

进程结构描述为`task_struct`，分配一个`PID`，默认上限数为一个`short int`，可修改文件来提高上限

## 进程家族树

进程为树形结构，所有进程都是`PID`为1的`init进程`的后代。

## 进程创建

- **fork调用**：写时复制。只有需要使用的时候才复制，其余共享同一个拷贝。通过`clone`调用来完成
- **vfork**：不复制父进程页表项，且子进程先执行，直到退出或执行exec

## 线程

跟创建进程一致，不过在使用`clone`系统调用会指定参数来共享资源，如`地址空间`、`文件资源`，`文件描述符`等

## 进程终结

首先调用`do_exit`后进程不能运行（僵尸进程），但需要父进程调用`wait4`后才能删除文件描述符

- **孤儿进程**：若父进程先退出，那么子进程变成孤儿进程，由init进程收养

## 进程调度

可执行进程组织到`红黑树`上，`阻塞`就是将进程从红黑树中移出，放入等待队列；`唤醒`就是相反的过程

## 内核栈

进程有两个栈，其中内核栈一般为1页或2页，用于内核态的进程执行，比如中断处理程序就可以使用。后来又独立了一个中断栈，单独用于处理中断程序。

# 二、内存管理（进程内存区域）

**关键词**：`虚拟、物理地址`、`进程地址空间、内存区域`

**面试概述**：

1.   Linux内存地址分为虚拟地址和物理地址，每个进程使用虚拟地址，通过地址转换映射到物理地址
2.   进程内存区域分为`代码段`、`数据段`、`BSS段`、`堆`、`栈`、`共享内存、内存映射等`、`动态链接库的相关代码数据`
3.   进程地址空间由内存描述符`mm_struct`描述，包含多个VMA（虚拟内存区域）、页表等内容; 内存区域由`vm_area_stuct`描述，代表不同的内存区域。在`mm_struct`通过`红黑树`（查找使用）和`链表`（遍历使用）

## 进程内存分布 

即内存区域包含的内容

- 代码段
- 数据段
- bss段（未初始化的全局变量）
- 用户空间栈
- 动态链接库相关的代码数据等
- 共享内存段，内存映射等

## 进程相关文件数据结构

进程描述符中有`file_struct`，代表已打开的文件对象
`fs_struct`，包含当前目录和根目录 

# 三、系统调用

每个系统调用都会分配一个系统调用号

- **调用过程**：
	- 通过引发一个异常来切换到内核态。x86系统通过int$0x80指令来触发异常并进行异常处理程序。
	- 用户会将系统调用号放入寄存器，然后系统调用处理程序就能从寄存器中获取调用号

# 四、中断

- **产生过程**：中断本质是一种电信号，由硬件设备产生送入中断控制器引脚，中断控制器与处理器通信，处理器收到后中断当前工作转而去处理中断

- **上半部**：上半部用于处理紧急迫切与硬件相关的工作，然后就中断完成，交还控制权（硬中断）

- **下半部** ：下半部用于处理与中断密切相关但上半部没有执行的任务（比如网卡读取数据后需要处理）。

	- **软中断**：首先注册软中断程序。中断处理程序完成后会标记软中断，以便它后面会执行。一般从一个硬件中断代码处返回时就触发软中断。

-  **定时器与时间管理**

	内核通过硬件上的`系统定时器`按照一定频率触发`时钟中断`来获得时间的概念，从而可以周期性的执行一些任务

#  五、Socket过程

- **socket()**：内核中有socket内核数据结构，由VFS创建相应的结构并与socket关联，然后返回一个文件描述符。本质就是分配了一块内存
- **bind（）**:设置socket结构体中的端口号
- **listen()**：设置socket结构体中的`state`为`TCP_LISTEN`，即将未连接的套接字变成被动套接字。本质就是改变了`state`的值
- **accept()**：它的作用只是去获取已经三次握手完成的scoket，然后返回就是了。其中三次握手是由协议栈完成，跟scoket无关。
	- 调用accept阻塞，然后协议栈三次握手后会将创建新的socket放入队列，然后唤醒accept去处理
	- 所以说当listen完成其实就可以建立连接了，不过没有调用accept没法去处理建立好的连接

 ![](http://abcdxyzk.github.io/images/kernel/2015-06-01.png)

# 六、IO多路复用 

## select

每次调用`select`需要将需要监听的`socket文件描述符`（通过accept获取）传入，然后内核会先轮询一遍，如果没数据就会将`进程`从`可运行队列`中拿出放入socket的`等待队列`。当数据到来后会产生中断，中断处理程序就会唤醒`进程`。即清除等待队列，然后放入`可运行队列`

**概述**：传入fd集合 ---->  将进程放入socket等待队列阻塞  --->   中断唤醒进程    ---->     用户进程从select返回，轮询fd查看值



## epoll

首先`epoll_create`创建epoll数据结构（包含`监视列表（红黑树）`、`就绪列表（双向链表，evenpoll）`、等待队列（进程））。然后`epoll_ctl`向监视列表中添加fd，将epoll对象放入socket的等待队列。调用`epoll_wait`阻塞等待`就绪列表`中有数据。数据到来后中断处理程序会将将socket放入就绪列表，然后唤醒epoll等待队列中的进程。



**概述**：创建epoll对象 ----> 添加监视fd ----> 调用epoll_wait阻塞等待 ----> 中断将socket放入就绪列表，唤醒进程 ----> 用户进程从epoll_wait返回并轮询得到的就绪列表

# 七、文件系统

## VFS-虚拟文件系统

Linux在具体的文件系统之上的一个抽象，不同的文件系统只需要实现统一的接口就能在Linux使用

- **超级块对象**
	代表具体的文件系统，有添加删除索引节点，写入磁盘等操作

- **索引节点对象**
	代表文件对象，仅当文件被访问时才会创建。包含了设备文件，管道等特殊文件

- **目录项对象**
	代表目录，用于方便查找操作，不会写入磁盘
	它有三种状态
	- 被使用，它的d_inide字段指向相应的索引节点，d_count代表被使用者个数
	- 未使用，指向具体的索引节点，但没使用者
	- 负状态（无效状态），没有对应索引节点，不撤销仅仅是为了方便以后解析路径

- **文件对象**
	代表进程打开的对象，它是已打开对象在内存中的表示，由open创建，close撤销，更接近用户角度的文件。由于多个进程可以打开同一个文件，所以同一个文件（索引节点）具有多个文件对象



# 八、内存分配

## slab层

由于一些数据结构频繁创建和回收，所以单独抽象出slab层用于缓存。
高速缓存包含多个slab，slab由一个或多个页组成。slab包含多个对象
slab有满，部分满，空三种状态。优先从部分满的slab取空闲的对象

# 九、页高速缓存与页回写

页缓存实现对磁盘的缓存

- **构建**：当读磁盘时，会首先检查页缓存；写磁盘时，操作页缓存，然后在另一个进程中对该页进行回写磁盘。
- **写时同步（回写）**：写磁盘时，操作页缓存，然后在另一线程（flusher ）中对该页进行回写磁盘。
- **内存回收**：双链策略的改进LRU算法
- **基树**：构建一颗二叉树用于检索缓存是否命中。（以前实现是散列表）

