#  一、进程管理

## 进程描述符

进程结构描述为`task_struct`，分配一个`PID`，默认上限数为一个`short int`，可修改文件来提高上限

## 进程家族树

进程为树形结构，所有进程都是`PID`为1的`init进程`的后代。

## 进程创建

- **fork调用**：写时复制。只有需要使用的时候才复制，其余共享同一个拷贝。通过`clone`调用来完成
- **vfork**：不复制父进程页表项，且子进程先执行，直到退出或执行exec

## 线程

跟创建进程一致，不过在使用`clone`系统调用会指定参数来共享资源，如`地址空间`、`文件资源`，`文件描述符`等

## 进程终结

首先调用`do_exit`后进程不能运行（僵尸进程），但需要父进程调用`wait4`后才能删除文件描述符

- **孤儿进程**：若父进程先退出，那么子进程变成孤儿进程，由init进程收养

## 进程调度

可执行进程组织到`红黑树`上，`阻塞`就是将进程从红黑树中移出，放入等待队列；`唤醒`就是相反的过程

## 内核栈

进程有两个栈，其中内核栈一般为1页或2页，用于内核态的进程执行，比如中断处理程序就可以使用。后来又独立了一个中断栈，单独用于处理中断程序。

# 二、内存管理（进程内存区域）

**关键词**：`虚拟、物理地址`、`进程地址空间、内存区域`

**面试概述**：

1.   Linux内存地址分为虚拟地址和物理地址，每个进程使用虚拟地址，通过地址转换映射到物理地址
2.   进程内存区域分为`代码段`、`数据段`、`BSS段`、`堆`、`栈`、`共享内存、内存映射等`、`动态链接库的相关代码数据`
3.   进程地址空间由内存描述符`mm_struct`描述，包含多个VMA（虚拟内存区域）、页表等内容; 内存区域由`vm_area_stuct`描述，代表不同的内存区域。在`mm_struct`通过`红黑树`（查找使用）和`链表`（遍历使用）

## 进程内存分布 

即内存区域包含的内容

- 代码段
- 数据段
- bss段（未初始化的全局变量）
- 用户空间栈
- 动态链接库相关的代码数据等
- 共享内存段，内存映射等

## 进程相关文件数据结构

进程描述符中有`file_struct`，代表已打开的文件对象
`fs_struct`，包含当前目录和根目录 

# 三、系统调用

每个系统调用都会分配一个系统调用号

- **调用过程**：
	- 通过引发一个异常来切换到内核态。x86系统通过int$0x80指令来触发异常并进行异常处理程序。
	- 用户会将系统调用号放入寄存器，然后系统调用处理程序就能从寄存器中获取调用号

# 四、中断
