# 计算机网络

## TCP、HTTP经典问题

<div>
<a href="Computer%20Network.md" target="_blank">TCP、HTTP经典问题
</div>

## 输入一个URL发生了什么

1.   DNS解析得到IP
       查询浏览器缓存
       客户端递归请求本地域名服务器
       本地域名服务迭代请求根服务器，顶级域名服务器等
     
2.   TCP三次握手建立连接 

     -    第一次握手：客户端发送 SYN 报文，并进入 SYN_SENT 状态，等待服务器的确认；

     -    第二次握手：服务器收到 SYN 报文，需要给客户端发送 ACK 确认报文，同时服务器也要向客户端发送一个 SYN 报文，所以也就是向客户端发送 SYN + ACK 报文，此时服务器进入 SYN_RCVD 状态；

     -    第三次握手：客户端收到 SYN + ACK 报文，向服务器发送确认包，客户端进入 ESTABLISHED 状态。待服务器收到客户端发送的 ACK 包也会进入 ESTABLISHED 状态，完成三次握手。

3.   发送HTTP请求
      请求报文由请求行（request line）、请求头（header）、请求体三个部分组成

4.   服务器处理请求返回HTTP报文
     响应报文由响应行（request line）、响应头部（header）、响应主体三个部分

5.   浏览器解析渲染画面

6.   TCP四次挥手断开连接

     -    第一次挥手。客户端发起 `FIN` 包（FIN = 1）,客户端进入 `FIN_WAIT_1` 状态。
     -    第二次挥手。服务器端收到 `FIN` 包，发出确认包 `ACK`，服务器端进入了 `CLOSE_WAIT` 状态。
     -    第三次挥手。服务器端数据发送完毕后，向客户端发送 `FIN` 包（seq=w ack=u+1），服务器此时进入了 `LAST_ACK` 状态。
     -    第四次挥手。客户端收到服务器的 `FIN` 包后，发出确认包（ACK=1，ack=w+1），此时客户端就进入了 `TIME_WAIT` 状态。注意此时 TCP 连接还没有释放，必须经过 `2*MSL` 后，才进入 `CLOSED` 状态。而服务器端收到客户端的确认包 `ACK` 后就进入了 `CLOSED` 状态。

## Http和Https区别

- https采用了ssl/tsl证书加密，加密方式使用了非对称加密和对称加密
- 端口号不同，80和443

## get和post区别

-    **用途**：get用于查询数据，不会改变服务器状态；post用于提交数据，可能会改变服务器状态
-    **参数**：get参数通过url传递，长度有限制（Apache 为8092个字符，8k）；post通过请求体传递，无限制
-    **可见性、缓存性**：get可见、限制为ascii字符，会被缓存；post不可见，不会被缓存

## request和response

request包括请求方法、URL、版本号、请求头、请求体

`GET http://www.baidu.com HTTP1.1`

response包括版本号、状态码、响应头、响应正文

`HTTP1.1 200 OK`

## https加密过程

​	客户端发送请求（包含自己支持的加密规则），服务端必须拥有ssl证书并选择加密规则（即一对公钥和私钥）；

​	服务端发送公钥，客户端验证证书，生成一个随机值（私钥），加密（通过公钥和约定好Hash值）后发给服务端

​	服务端收到后用私钥解密出随机值。后面传输就使用这个随机值用作加密；

## 证书分类

- **验证方式**
     - DV证书：只验证域名有效性，个人用户使用，比如博客等
     - OV证书：验证域名和企业信息，企业用户使用
     - EV证书：扩展性验证，比如电话回访等。会在地址栏显示企业名称并且地址变为绿色。
- **域名数量**
     - 单域名：只保护单个域名
     - 多域名：保护多个域名及其子域名，适合顶级域名较多的用户
     - 通配符域名：保护一个域名以及子域名，不限制数量。适合子域名较多的用户

## Https的攻击方式

- **中间人攻击**：攻击者分别与通讯的两端建立单独的联系，并交换其会话内容。前提是中间人要能够伪装成每个参与会话的终端而不被发现
- **下载证书**：比如12306以前采用自己颁发的证书，用户首次使用需要下载安装证书，这个过程容易下载安装非法的证书。

## HTTP状态码

- 1-服务器收到请求，需要请求者继续执行操作；2-成功接收；3-重定向；4-客户端错误；5-服务器错误
- 100：客户端应继续请求
- 200：get/post成功
- 204:服务器未返回任何内容
- 301-302：永久移动和临时移动
- 403-404：拒绝请求和未找到网页
- 500、502、503：服务器内部错误、网关错误、服务暂时不可用

## Http1.0，1.1，2.0区别

- 1.0短连接（浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接）
- 1.1**长连接**（每次连接可以处理多个请求，而不是处理完后立即断开），增加缓存处理、支持**断点续传**（头部中的Range字段指明传输的起始位置）
- 2.0多路复用（允许同时通过**单一的 HTTP/2 连接**发起**多重的请求-响应**消息。因此 HTTP/2 可以很容易的去实现多流并行而不用依赖建立多个 TCP 连接），压缩头部、**基于二进制**

## 大量Time_wating状态原因

​	这个状态是主动关闭连接后产生的，一般是高并发下建立多个短连接，处理完后关闭，不能及时的回收和重用

​	解决办法就是：调整内核参数，实现socket连接的快速回收和重用

## 大量Close_wating状态原因

​	这个状态是被动关闭时产生的，一般是服务器端忘记关闭连接资源造成的，比如代码中忘记写close函数来关闭socket连接

## ping

属于应用层，基于ICMP协议
用于探测本机与网络中的主机是否可达

-    telnet 探测TCP端口
-    netcat 探测UDP端口

## 高并发服务器设计

如果客户端请求数量特别多怎么保证服务器的服务？（如何能加快http请求速度？）

-    服务端：
     1.   IO多路复用提升连接数
     2.   分布式服务，采用多台服务器，负载均衡减轻压力
     3.   使用缓存，包括本地缓存和Redis集群
     4.   限流

-    客户端
     1.   资源静态化，缓存
     2.   CDN加速

# 操作系统

## 分区、分页、分段

-    **分区**

     -    固定分区：每次都给进程分配固定大小的内存。

          易产生`外部碎片`：各区之间未被使用的；和`内部碎片`：区内未使用的

     -    动态分区：维护空闲列表，每次分配从空闲列表中获取

          -    首次适应算法：地址递增，每次都从低地址开始寻找。低地址碎片
          -    循环适应算法：从上次的位置开始寻找。避免碎片集中低地址
          -    最佳适应算法：内存大小递增
          -    最差适应算法：内存大小递减

-    **分页**

​		用户空间划分成相等大小的部分称为页，内存空间划分为同样大小的区域称为页框，分配时以页为单位。逻辑相邻的页物理上不一定相邻

-    **分段**

​		用户进程地址空间按照自身逻辑划分成多个段（如代码段、数据段、堆栈段），内存空间被动态划分成不同长度的区域，分配时以段为单位。每段是内存连续。各段不一定连续

-    **段页式**

     用户空间先分段、再分页。内存空间分页，分配以页为单位

-    **段页区别**

     -    **目的**：分页的目的是管理内存，用于虚拟内存以获得更大的地址空间；分段的目的是满足用户需要，使程序和数据可以划分成单独的地址空间
     -    **大小**：分页大小固定、由系统决定；分段大小不一、由用户需要决定
     -    **地址维度**：分页是一维，每个进程有页表，通过一个逻辑地址就能找到对应物理地址；分段是二维的，需要段号+段内偏移量

## 虚拟内存

​		划分成页---部分保存----缺页中断-----逻辑上更大的地址空间

​		每个程序都拥有自己的地址空间，这个地址空间被分成大小相等的页，这些页被映射到物理内存；但不需要所有的页都在物理内存中，当程序引用到不在物理内存中的页时，产生缺页中断（硬件的地址转换机构），由操作系统将缺失的部分装入物理内存。这样，对于程序来说，逻辑上似乎有很大的内存空间，只是实际上有一部分是存储在磁盘上，因此叫做虚拟内存。

虚拟内存的优点是让程序可以获得更多的可用内存。

虚拟内存的实现方式：页表/多级页表、缺页中断、不同的页面淘汰算法

### 缺页中断-页面置换算法

- 最佳置换算法OPT：淘汰将长时间不用的页面
- 先进先出FIFO
- 最近最少使用LRU（时间）：双向链表维护、HashMap可用于快速查找
- 最近不经常使用LFU（次数）：
- Clock时钟置换算法：设置访问位和修改位，优先淘汰未访问和未修改的页

## select/poll和epoll区别

-    **select/poll**：每次调用都要将所有文件描述符传入内核阻塞等待，当数据到来后就唤醒返回。但由于不知道哪一个文件描述符就绪，所有需要轮询整个描述符集合
-    **epoll**：epoll需要先将描述符注册到监视列表，当数据到来会将描述符放入列表返回。用户只需要遍历就序列表，而不需要遍历整个集合，而且描述符只需注册一次，而不需要每次都传入。对于水平触发，只要描述符还有数据就会通知；对于边沿触发，只有当数据到来从无到有才会通知

## BIO、NIO、IO多路复用区别

BIO是阻塞在一个线程上直到读写完成。

NIO是读写操作后立即返回，无论有无数据。所以用户要循环调用查看数据是否就绪，涉及到用户态和内核态的反复切换。

IO多路复用是将轮询的任务交给系统调用如epoll，一个线程就能管理多个连接。

## 死锁

四个必要条件

-    资源互斥
-    不可抢占
-    请求与保持
-    环路等待

预防措施

-    （请求与保持）资源统一分配，不允许分配部分资源。如A，B资源要么一起分配，要么不分配；
-    （环路等待）资源编号，分配必须按照顺序来。

避免措施

-    银行家算法

# Java

## 重写equals必须重写hashcode

在A.equals(B)返回true的情况下，A, B 的hashCode()要返回相同的值．这样才能在HashSet等hash表结果中得到正确的结果。比如contains方法

## Java同步机制

-    Synchronizied
-    Lock接口及其实现类
-    基于AQS实现的一些同步工具类如
     -    CountDownLatch（wait和countdown）：用于主线程等待多个子线程执行结束，不可复用
     -    CycliBarrier (await)：用于一个任务分成多个阶段来顺序执行，可服用
     -    信号量semaphore：（管理多个数量的某种资源的同步使用）

## 线程安全的实现方式

-    互斥同步
     sync锁，lock锁
-    非阻塞同步
     CAS+volatile
     atomtic原子类

## synchronizied和lock区别，具体实现

​	中断---阻塞队列---释放锁

- sync是关键字，基于JVM实现；Lock是接口，基于JDK实现类底层用CAS实现
- sync不可中断、单一阻塞队列；lock可中断、多条件变量阻塞队列
- sync异常会释放锁，Lock需手动释放锁

syn基于JVM实现，通过`monitorenter`和`monitorexit`两个字节码指令实现加锁解锁
lock基于AQS实现，维护一个vatile的state变量表示锁的状态，通过CAS操作来改变。以及一个双向链表，用作阻塞队列\

## Java三大特性

### 继承

将多个相同属性和方法提取出来，新建一个父类，然后子类继承父类的特征和行为，一个类只能继承一个父类，而且只能继承访问权限非private的属性和方法

可以提高代码的可扩展性、可复用性

### 封装

封装其实就是把“类”的“过程”和“数据”装起来，而且对于该数据的访问只能够通过先前已定义的接口才能够访问

限制对数据的不合理访问、提高代码的复用性

### 多态

​	多态是指一个引用变量所指向的具体类型、以及方法调用可以在运行时动态绑定

​	实现条件有三个：继承、重写、向上转型

​	首先需要继承，拥有子类；然后子类重写父类方法；new 一个子类对象的时候使用父类引用去接收，实现向上转型；

​	然后操作父类引用类型就能调用不同的子类的方法

​	

消除类型之间的耦合关系，实现低耦合；调用更加灵活

## 抽象类和接口

1.   接口的变量只能是public static final，必须赋值。抽象类可以有各种变量
2.   接口不能有构造器和代码块
3.   1.8的接口除了静态方法和default修饰的方法，普通方法不能有方法体。抽象类可以实现也可以不实现
4.   抽象类单继承，接口可以多实现。

## GC过程

​	JVM将内存分代，分为新生代、老年代、永久代，其中新生代又分为eden区和两个survive区；

​	新生对象就在eden区分配内存，当Eden区内存不足时，触发第一次minorGC，将eden区存活对象拷贝到一个survive区；

​	当再一次用完之后，就将两个区拷贝到另一个survive区，由此采用复制算法循环；

​	每GC一次，存活对象年龄就增大一岁，一般到达15岁就转移到老年代；老年代空间不足就会触发full gc

## Object类的方法

-    锁：wait、notify、notifyAll
-    toString、hashCode、equals、clone
-    反射：getClass

## Java线程启动start过程

​	首先检查threadStatus为0，判断该线程是否为NEW状态，否则抛出`IllegalThreadStateException`

​	其次将其加入线程组，一般用户创建的线程默认为main线程组

​	然后调用native方法start0

​	start0通过C++系统库创建线程，Linux下是通过fork和clone系统调用来创建一个子进程，并决定它共享的内容来表示线程

## 如何实现锁

​	维护一个volatile的state变量表示锁的状态，以及一个双向链表表示等待队列。

​	获取锁的时候判断线程是否获取过锁，通过CAS操作来改变state变量的值；获取失败就加入等待队列

## OOM

- **堆溢出**：频繁创建大对象，或者出现了内存泄露导致内存没有回收；可以通过dump文件查看对象引用链，判断创建对象的代码是否有问题
- **方法区溢出**：使用的类过多，class对象过多。可以合理调整方法区的大小

## String不可变原因

- **常量池**：多个相同字符串指向常量池的同一块内存
- **安全性**：当用String做参数传递，由于不可变保证了不会被篡改；又比如在HashSet中，如果使用可变的StringBuilder，那么hashset的唯一性会被破坏

# Linux常用命令

## 速记各种查看

-    `top -c`：查看CPU
-    `free`：查看内存
-    `df -k`：查看磁盘
-    `lsof -i`：查看端口占用
-    `find -mtime`：查看24小时内修改过的文件

## find和grep

find是查找文件和目录位置

grep是在文件中查找字符串 

# 各种问题排查

![](https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naJr6V2cHcuYObZ7sh4aHQKL8azibBpL7sOow4GQxFbdXR6cI8TZdLlQw5kGXGxHp6120Z4eEPfibtwA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

## CPU100%排查

- 查看CPU100%的进程PID（`top -c`）

- 查看该进程下的哪个线程消耗最高（`top -H -p <java 进程pid>`）

- 根据线程号查到Java线程，然后导出快照，然后搜索该线程看看做了什么（一般是代码死循环，可以查看哪行一直在运行）

     `jstack -l <其中一个线程PID>`

## 内存泄露排查

1. 用工具（如jmap）生成java应用程序的heap dump
2. 查看内存占用过高的对象
3. 分析对象的引用关系
4. 分析源代码，查看是否有未关闭的资源、频繁创建大对象等

## OOM排查

​	与内存泄露类似

1.   设置JVM参数自动导出dump文件：`heapDumpOnOutOfMemoryError heapDumpPath`
2.   分析内存快照文件，查看内存占用的对象
3.   判断源代码是否有内存泄露

## 慢查询/SQL

1.   使用`explain`分析SQL执行计划，判断`type`列的连接类型，查看`key`列使用的索引
2.   添加索引、分析避免索引失效、加上限定范围避免全表扫描、避免返回不必要的列等

## 死锁

### linux死锁

1.   使用`pstack`打印进程调用栈信息，分析进程在哪里挂起了以及挂起的原因

### Java线程死锁

1.   使用`jstack`打印线程堆栈信息，分析挂起的原因

### MySQL死锁

1.   利用 `select @tx_isolation` 命令获取到数据库隔离级别信息：
2.   利用 `show engine innodb status` 命令获取死锁日志
3.   查看事务持有的锁，分析死锁的原因。如`两个事物对这条记录同时持有S锁(共享锁)的情况下，再次尝试获取该条记录的X锁(排它锁)，从而导致互相等待引发死锁`
4.   根据死锁日志的SQL语句定位代码。

# 数据库

## redis为什么是单线程

我们所说的Redis单线程，指的是"其网络IO和键值对读写是由一个线程完成的"，也就是说，Redis中只有`网络请求模块`和`数据操作模块`是单线程的。而其他的如持久化存储模块、集群支撑模块等是多线程的

持久化存储模块、集群支撑模块等是多线程的。

- 因为redis基于内存，它的性能瓶颈不是CPU
- 单线程实现简单。免去上下文切换的时间
- 采用了IO多路复用技术，解决IO瓶颈

## 范式

- **一范式**：属性不重复，即单个属性不可再分割
- **二范式**：属性依赖于主键
- **三范式**：属性不依赖于其他非主属性

# Spring

## springboot和spring的区别

spring提供了ioc和aop等功能
springboot在spring基础上简化了大量配置，做到了自动装配，且内嵌tomcat，使用更加简便。

## 自动装配（简化配置）

1.   `@SpringBootApplication`中包含`EnableAutoConfiguration`开启自动装配
2.   启动后会寻找包含`META-INF/spring.factories`文件的jar包。该文件就是一组一组的`key-value`形式的值，其中一个key是EnableAutoConfiguration类的全类名，而它的value是一个xxxxAutoConfiguration的类名的列表
3.   执行selectImports()方法，找到所有对应的自动配置类，将其**按需**加载到Spring容器中。
4.   每一个自动配置类都是在某些条件之下才会生效的

```
@ConditionalOnBean：当容器里有指定的bean的条件下。

@ConditionalOnMissingBean：当容器里不存在指定bean的条件下。

@ConditionalOnClass：当类路径下有指定类的条件下。

@ConditionalOnMissingClass：当类路径下不存在指定类的条件下。
```



## IOC&AOP

-    **IOC**：IOC控制反转，就是将原本在程序中手动创建对象的控制权交给容器。当我们需要创建一个对象的时候，只需要配置好相应文件或注解即可，完全不用考虑对象是如何被创建出来的

     好处就是能够很方便的管理各个对象的依赖关系以及进行依赖注入，还能通过单例模式防止创建多个重复对象

-    **AOP**：面向切面编程。能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于程序扩展、降低耦合度

     -    动态代理：JDK动态代理（通过`Proxy`类，传入类加载器、接口、`InvacationHandle`生产成代理类）

## 循环依赖

-    **面试回答**：Spring 为了解决单例的循环依赖问题，使用了 **三级缓存** 。非单例直接创建新对象。

先让最底层对象完成初始化，通过三级缓存与二级缓存提前曝光创建中的 Bean，让其他 Bean 率先完成初始化。

-    **详解**：

单例模式的 Bean 保存在如下的数据结构中：

```Java
/** 一级缓存：用于存放完全初始化好的 bean **/
private final Map<String, Object> singletonObjects = new ConcurrentHashMap<String, Object>(256);

/** 二级缓存：存放原始的 bean 对象（尚未填充属性），用于解决循环依赖 */
private final Map<String, Object> earlySingletonObjects = new HashMap<String, Object>(16);

/** 三级级缓存：存放 bean 工厂对象，用于解决循环依赖 */
private final Map<String, ObjectFactory<?>> singletonFactories = new HashMap<String, ObjectFactory<?>>(16);

/**
bean 的获取过程：先从一级获取，失败再从二级、三级里面获取

创建中状态：是指对象已经 new 出来了但是所有的属性均为 null 等待被 init
*/
```
检测循环依赖的过程如下：

-    A 创建过程中需要 B，于是 **A 将自己放到三级缓里面** ，去实例化 B

-    B 实例化的时候发现需要 A，于是 B 先查一级缓存，没有，再查二级缓存，还是没有，再查三级缓存，找到了！

-    -    **然后把三级缓存里面的这个 A 放到二级缓存里面，并删除三级缓存里面的 A**
     -    B 顺利初始化完毕，**将自己放到一级缓存里面**（此时B里面的A依然是创建中状态）

-    然后回来接着创建 A，此时 B 已经创建结束，直接从一级缓存里面拿到 B ，然后完成创建，**并将自己放到一级缓存里面**

-    如此一来便解决了循环依赖的问题

上述代码描述

```Java
protected Object getSingleton(String beanName, boolean allowEarlyReference) {
    Object singletonObject = this.singletonObjects.get(beanName);
    if (singletonObject == null && isSingletonCurrentlyInCreation(beanName)) {
        synchronized (this.singletonObjects) {
            singletonObject = this.earlySingletonObjects.get(beanName);
            if (singletonObject == null && allowEarlyReference) {
                ObjectFactory<?> singletonFactory = this.singletonFactories.get(beanName);
                if (singletonFactory != null) {
                    singletonObject = singletonFactory.getObject();
                    this.earlySingletonObjects.put(beanName, singletonObject);
                    this.singletonFactories.remove(beanName);
                }
            }
        }
    }
    return (singletonObject != NULL_OBJECT ? singletonObject : null);
}
```



## beanFactory和Factorybean

