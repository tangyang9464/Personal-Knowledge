### 一、多线程

#### Java线程状态

- New
- RUNNABLE--包括就绪和运行
- BLOCKED--等待锁
- WAITING--wait方法、需要其他线程唤醒
- TIMED_WAITING--超时等待
- TERMINATED--结束

#### 进程与线程的区别

- 线程是进程的一个子任务

- 进程是资源分配的基本单位、线程是调度的基本单位（**调度**）

- 进程单独占有内存空间地址及其他系统资源（如IO）（**资源**），通信复杂

  线程共享所属进程的内存地址空间和资源，通信简单

- 进程切换不仅需要保存寄存器和栈信息，还需要资源的分配回收、开销较大、线程只需要保存栈和寄存器开销小（**开销**）

#### 创建线程的方法

- 继承Thread方法、重写run方法
- 实现Runnable接口的run方法
- Executor（线程池）
- FutureTask（有返回值）

#### Java线程4种通信方式

- 共享变量：使用volatile修饰的变量
- 等待/通知机制：wait、notify
- 管道：pipeReder
- 消息队列

#### volatitle作用

- 保持**线程可见性**：一个线程修改了共享变量的值，其他线程能立即得知这个修改。（线程有私有本地内存，修改变量后刷新回主内存，但其他线程的私有内存并没有更新，还是使用的旧值。）
- 防止**指令重排序**:计算机在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排

#### 并发三点特性（volatitle和synchronized）

- **原子性**：一个或多个操作执行过程中不被打断的特性
- **可见性**：一个线程改变了共享变量之后，其他线程能够立即知道这个变量被修改
- **有序性**：程序按照代码先后顺序执行

#### synchronized锁升级（Java6以后）

- **无锁**
- **偏向锁**：（不需要锁和CAS）
  - **概念**：偏向锁会偏向于第一个访问锁的线程，如果在接下来的运行过程中，该锁没有被其他的线程访问，则持有偏向锁的线程将永远不需要触发同步
  - **升级**：若有新的线程，则尝试CAS更新，失败就升级锁
  - **获取锁**：第一次进入同步块时，会在对象头和栈帧中的锁记录里存储锁的偏向的线程ID，下一次检查锁的Mark Word里面是不是放的自己的线程ID
- **轻量级锁（自旋锁）**：
  - **概念**：通过自旋获取锁
  - **获取锁**：将MarkWord复制到自己的栈，然后尝试CAS更新MarkWord为指向此锁记录的指针，失败就使用自旋
  - **升级**：自旋次数过多，就升级。
- **重量级锁**
  - **概念**：依赖于操作系统的互斥量（mutex） 实现的，需要线程状态转换。

#### synchronized底层实现

JVM基于进入和退出monitor对象来实现方法和代码块同步

- **方法**：隐式，无需字节码指令；

	调用方法时检查标志是否为同步方法，尝试持有monitor对象

	返回时释放对象

- **代码块**：通过monitorenter和monitorexit两个字节码指令

	分别位于开始和结束的位置

	monitorenter指令执行尝试获取锁，计数器+1

	monitorexit指令执行计数器-1，变为0就释放

#### 乐观锁与悲观锁

- **乐观锁**：数据操作不加锁，只在最终更新数据的时候才检验当前数据是否被修改过，也就是CAS操作
- **悲观锁**：数据操作之前需要加锁，完成后释放锁

#### 原子操作

- 要么执行完所有步骤，要么一步也不执行，不可能只执行所有步骤的一个子集的一组操作
- **CAS**：
  - 比较并交换，是一种不需要加锁就能完成原子操作的技术；判断要修改的变量是否等于预期值，等于就更新值；不等于则说明变量被其他线程修改过了，此次操作失败，重新进行操作，不会挂起
  - ABA问题：一个值原来是A，变成了B，又变回了A。这个时候使用CAS是检查不出变化的，解决方法是变量加版本号或时间戳
  - 缺点：ABA、循环消耗CPU（循环一定时间后睡眠），只能共享一个变量
- **Atomic类**

#### AQS（Lock的底层实现）

- 抽象队列同步器，提供了一种实现阻塞锁和一系列依赖FIFO等待队列的同步器的框架

- **数据结构**：volatile变量state，双向链表（等待队列）
- **资源共享模式**：独占式、共享式
- **state的访问方式**
  - getState
  - setState
  - compareAndSetState
- **获取资源**：获取到就返回，没有就通过CAS将线程Node插入等待队列，通过state判断资源是否加锁，通过等待队列来存放阻塞的队列

#### 线程池

##### 创建方式

- **ThreadPoolExecutor**：提供7大参数自定义
- **Executor**：创建特定的线程池，如4种常用的线程池

##### 组成

- **线程管理池**：负责线程池的创建销毁等
- **工作线程**：循环执行任务，没有任务就等待
- **任务接口**：每个任务需要实现任务接口供工作线程调度，规定了任务的入口，收尾状态等
- **任务队列**：存放等待执行的任务

#####  **使用原因**
  - 创建/销毁线程需要消耗系统资源，线程池可以**复用已创建的线程**。
  - **可以对线程做统一管理，控制并发的数量**。并发数量过多，可能会导致资源消耗过多，从而造成服务器崩溃。（主要原因）
##### **状态**
  - RUNNING
  - SHURDOWN
  - STOP
  - TIDYING：所有任务终止并且任务数为0
  - TERMINATED
##### **ThreadPoolExecutor的5大参数**
  - corePoolSize：核心线程的最大值（核心线程默认会一直存在，非核心闲置过久会销毁）
  - maximumPoolSize：最大线程数
  - keepAliveTime：非核心线程闲置时间
  - TimeUnit：keepAliveTime的单位（毫秒、秒等）
  - BlockingQueue ：存储着等待执行的Runable任务对象
    - LinkedBlockingQueue
    - ArrayBlockingQueue
    - SynchronousQueue（put和take操作）
    - DelayQueue
##### **ThreadPoolExecutor的2个非必要参数**
  -  threadFactory：设置一些参数，如守护线程等
  - RejectedExecutionHandler：拒绝处理策略
##### **拒绝处理策略（超出最大线程数后）**
  - 默认-丢弃任务并抛出异常
  - 只是丢弃任务
  - 丢弃队列头部并重新尝试执行，若失败再次重复
  - 交给调度线程处理
##### **执行流程**
  - 线程数 < corePoolSize,新建核心线程执行，以便快速达到corePoolSize
  - 线程数>=corePoolSize，进入等待队列，空闲的核心线程会依次去缓存队列中取任务来执行
  - 队列满了后新建非核心线程
  - 达到maximumPoolSize后执行拒绝策略
##### **复用**

- 完成任务后会循环的从队列中取出任务来执行而不是销毁，如果没有任务执行就阻塞

##### **4种提供的常用线程池**
  - CachedThreadPool：只有非核心线程，线程池数量多（Integer.MAX_VALUE，2的31次方-1），适合短时间任务
  - FixedThreadPool：只有核心线程，缓冲队列长；没有任务的情况下， FixedThreadPool占用资源更多
  - SingleThreadExecutor：单一核心线程，通过先来先服务执行任务
  - ScheduledThreadPool：定长线程池，支持定时及周期性任务执行

#### 阻塞队列

- **定义**：提供了线程安全的队列访问方式
- **类型**
  - **有界**
    - ArrayBlockingQueue：初始化容量后不能改变，基于数组
    - LinkedBlockingQueue：容量为Integer.MAX_VALUE。线程池的使用队列
  - **无界**
    - DelayQueue：在一定延迟后才能取数据
    - PriorityBlockingQueue：内部采用公平锁
    - SynchronousQueue：put后必须take，否则阻塞等待，反之亦然；
- **原理**：使用Lock锁的多条件阻塞
  - Lock锁的多条件阻塞：同一把锁，提供多个阻塞队列，而不是像wait/notify是一把锁只有一个队列
  - 获取锁、判断队列满或空、阻塞或执行、唤醒另一条件线程（生产者和消费者）

#### 锁的接口和类（Lock）

- **与synchronized区别（层面、锁释放、中断、判断）**
  - synchronized是关键字，字节指令实现；Lock是接口，实现类底层用CAS实现
  - synchronized异常会释放锁，Lock需要在finally中释放
  - synchronized不可中断，不能判断锁状态
  - synchronized功能单一，Lock提供更多个性化		

- **接口Lock的实现类**
  - ReentrantLock：默认实现，包括公平（FIFO）和非公平
- **ReadWriteLock接口**
  - ReentrantReadWriteLock：读写锁，可以返回读锁和写锁
- **StampedLock**：比读写锁性能更好，在读的时候如果发生了写，应该通过重试的方式来获取新的值，而不应该阻塞写操作。（CAS自旋） 

