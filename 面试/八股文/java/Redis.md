#### Redis

##### 数据结构

- **list**：双向链表
- **set**：hashTable
- **zset**：比set多了一个score参数，可用于排序
- **hash**：hashTable
- **string**：字符串键值对、动态字符串

##### 缓存穿透

大量请求的 key （一定不存在）根本不存在于缓存中，导致请求直接到了数据库上，根本没有经过缓存这一层

- 解决：**布隆过滤器**或者缓存空值，设置过期时间很短

**布隆过滤器**：位数组，用K个hash函数计算key得到多个位置，将位数组中对应位置置为1

若查询不存在就一定不存在，若存在可能几率误判

##### 缓存击穿

**某个key**失效，大量请求同时到来

- 解决：利用redis设置互斥锁，获取不到锁的线程就等待缓存值被写入，重新尝试查询缓存值

##### 缓存雪崩

同一时刻**多个key**大面积失效或者**redis宕机**，导致请求全部到了数据库

- 解决：集群缓存+基础时间上加上一个随机时间+限流降级等

##### 3种缓存策略

- **Cache-Aside**：读缓存，没有就读db，写入缓存；写db，删除缓存
- **Write/Read-Through**：与上面类似，区别是程序**只跟缓存打交道**，读写db交给缓存去做。write适用于频繁读取，不能忍受数据不一致
- **Write-Behind**：与上述区别是不会立即写入数据库，而是**异步方式**

##### 分布式锁

- 使用setNX+expire设置，并用Lua脚本保证原子性

	**问题**：

	- 单点故障：主Redis获取了锁，还没有同步就宕机了；又从其他redis节点获取了锁，重复获取

		使用RedLock解决

	- 只能非阻塞：使用Redission解决

- RedLock

	- 从多个节点中去获取锁

	- 若获取到超过半数的锁且所用时间小于失效时间就成功

	- 如果获取锁小于半数或者所用时间超过了失效时间，那么就对所有节点进行解锁（只会解除自己上的锁）

		，因为可能上锁成功但是超时没响应了。

##### 主从、哨兵、集群

- 主从复制：从节点发送同步命令，主节点执行BGSAVE命令生成RDB文件，并在缓冲区中存储后面执行的命令

	然后将rdb文件发给从节点，可以达到执行命令时的状态；再把缓冲区中的命令发给从节点（这是执行复制过程中产生的命令）

- 哨兵模式：在主节点挂掉进行切换的时候需要自动完成，设置多个哨兵监视主节点和其下的所有从节点

- 集群：多个独立的节点，通过Cluster Nodes命令和Cluster Meet命令，添加和连接节点形成集群。

##### 高效率的原因

- 单线程免去上下文切换
- IO多路复用
- 基于内存

##### BIO、NIO、AIO区别

- 同步阻塞：数据的读取写入必须阻塞在一个线程内等待其完成。（水壶烧水比喻：一个线程只能等待一个水壶）
- 同步非阻塞：不断轮询**多个IO**的状态，然后执行（多个水壶）（通过选择器来选择）
- 异步非阻塞：通过回调函数来确保读写准备好了之后进行读写
- 同步异步、阻塞非阻塞：同步异步是调用者能否立即得到结果，阻塞非阻塞是程序等待调用结果的状态（挂不挂起）

##### NIO

- **缓冲区Buffer**：所有数据通过缓冲区处理，保存读写数据
- **通道Channel**：通过它来读取和写入数据，和流的区别是它是全双工
- **多路复用器Selector**：监听多个通道的状态，决定是否操作

##### IO多路复用

一个线程管理多个IO请求，通过OS的系统调用支持

- **select**：通过轮询整个IO请求集合，当有数据到达就通知用户;监视的数目有限制，在Linux上一般为1024
- **poll**：与select类似，不过表示文件描述符集合的数据结构不同，且没有上限
- **epoll**:使用事件的就绪通知方式，先在内核注册fd，一旦fd就绪，就放入就绪链表。只需要查看就绪链表就行，而不是轮询整个集合

**内核空间**

内核空间拥有更大的权限，可以访问底层硬件比如IO等资源

用户空间访问IO等资源需要通过进入内核空间来执行，而不是直接调用资源

**进入方式**

- 系统调用
- 异常
- 外围设备中断

